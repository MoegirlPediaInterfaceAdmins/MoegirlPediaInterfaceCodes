/**
 * Generated by scripts/browserify/index.js
 * Options:
 *     module: "cron"
 *     entry: "Cron"
 *     gadget: { "name": "cron", "fileName": "MediaWiki:Gadget-cron.js" }
 *     prependCode: "const require = () => window.luxon;"
 */
const require = () => window.luxon;
!function() {
    function createModuleFactory(t) {
        var e;
        return function(r) {
            return e || t(e = {
                exports: {},
                parent: r
            }, e.exports), e.exports;
        };
    }
    var root, factory, _$CronJob_4 = createModuleFactory(function(module, exports) {
        module.exports = function(CronTime, spawn) {
            function fnWrap(cmd) {
                let command, args;
                switch (typeof cmd) {
                  case "string":
                    return args = cmd.split(" "), command = args.shift(), spawn.bind(void 0, command, args);

                  case "object":
                    var options;
                    if (command = cmd && cmd.command) return args = cmd.args, options = cmd.options, spawn.bind(void 0, command, args, options);
                }
                return cmd;
            }
            function CJ(cronTime, onTick, onComplete, startNow, timeZone, context, runOnInit, utcOffset, unrefTimeout) {
                let _cronTime = cronTime, argCount = 0;
                for (let i = 0; i < arguments.length; i++) void 0 !== arguments[i] && argCount++;
                return "string" != typeof cronTime && 1 === argCount && (onTick = cronTime.onTick, onComplete = cronTime.onComplete, context = cronTime.context, startNow = cronTime.start || cronTime.startNow || cronTime.startJob, timeZone = cronTime.timeZone, runOnInit = cronTime.runOnInit, _cronTime = cronTime.cronTime, utcOffset = cronTime.utcOffset, unrefTimeout = cronTime.unrefTimeout), this.context = context || this, this._callbacks = [], this.onComplete = fnWrap(onComplete), this.cronTime = new CronTime(_cronTime, timeZone, utcOffset), this.unrefTimeout = unrefTimeout, addCallback.call(this, fnWrap(onTick)), runOnInit && (this.lastExecution = new Date(), fireOnTick.call(this)), startNow && start.call(this), this;
            }
            function addCallback(callback) {
                "function" == typeof callback && this._callbacks.push(callback);
            }
            CJ.prototype.addCallback = addCallback, CJ.prototype.setTime = function(time) {
                if ("object" != typeof time) throw new Error("time must be an instance of CronTime.");
                var wasRunning = this.running;
                this.stop(), this.cronTime = time, wasRunning && this.start();
            }, CJ.prototype.nextDate = function() {
                return this.cronTime.sendAt();
            };
            const fireOnTick = function() {
                for (let i = this._callbacks.length - 1; 0 <= i; i--) this._callbacks[i].call(this.context, this.onComplete);
            }, start = (CJ.prototype.fireOnTick = fireOnTick, CJ.prototype.nextDates = function(i) {
                return this.cronTime.sendAt(i);
            }, function() {
                if (!this.running) {
                    const MAXDELAY = 2147483647, self = this;
                    let timeout = this.cronTime.getTimeout(), remaining = 0, startTime;
                    function _setTimeout(timeout) {
                        startTime = Date.now(), self._timeout = setTimeout(callbackWrapper, timeout), self.unrefTimeout && "function" == typeof self._timeout.unref && self._timeout.unref();
                    }
                    function callbackWrapper() {
                        var diff = startTime + timeout - Date.now();
                        if (0 < diff) {
                            let newTimeout = self.cronTime.getTimeout();
                            newTimeout > diff && (newTimeout = diff), remaining += newTimeout;
                        }
                        self.lastExecution = new Date(), remaining ? (remaining > MAXDELAY ? (remaining -= MAXDELAY, timeout = MAXDELAY) : (timeout = remaining, remaining = 0), _setTimeout(timeout)) : (self.running = !1, self.runOnce || self.start(), self.fireOnTick());
                    }
                    this.cronTime.realDate && (this.runOnce = !0), 0 <= timeout ? (this.running = !0, timeout > MAXDELAY && (remaining = timeout - MAXDELAY, timeout = MAXDELAY), _setTimeout(timeout)) : this.stop();
                }
            });
            return CJ.prototype.start = start, CJ.prototype.lastDate = function() {
                return this.lastExecution;
            }, CJ.prototype.stop = function() {
                this._timeout && clearTimeout(this._timeout), this.running = !1, "function" == typeof this.onComplete && this.onComplete();
            }, CJ;
        };
    }), _$CronTime_5 = createModuleFactory(function(module, exports) {
        const CONSTRAINTS = [ [ 0, 59 ], [ 0, 59 ], [ 0, 23 ], [ 1, 31 ], [ 0, 11 ], [ 0, 6 ] ], MONTH_CONSTRAINTS = [ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ], PARSE_DEFAULTS = [ "0", "*", "*", "*", "*", "*" ], ALIASES = {
            jan: 0,
            feb: 1,
            mar: 2,
            apr: 3,
            may: 4,
            jun: 5,
            jul: 6,
            aug: 7,
            sep: 8,
            oct: 9,
            nov: 10,
            dec: 11,
            sun: 0,
            mon: 1,
            tue: 2,
            wed: 3,
            thu: 4,
            fri: 5,
            sat: 6
        }, TIME_UNITS = [ "second", "minute", "hour", "dayOfMonth", "month", "dayOfWeek" ], TIME_UNITS_LEN = TIME_UNITS.length, PRESETS = {
            "@yearly": "0 0 0 1 0 *",
            "@monthly": "0 0 0 1 * *",
            "@weekly": "0 0 0 * * 0",
            "@daily": "0 0 0 * * *",
            "@hourly": "0 0 * * * *",
            "@minutely": "0 * * * * *",
            "@secondly": "* * * * * *",
            "@weekdays": "0 0 0 * * 1-5",
            "@weekends": "0 0 0 * * 0,6"
        }, RE_WILDCARDS = /\*/g, RE_RANGE = /^(\d+)(?:-(\d+))?(?:\/(\d+))?$/g;
        module.exports = function(luxon) {
            function CT(source, zone, utcOffset) {
                if (this.source = source, zone) {
                    if (luxon.DateTime.fromObject({}, {
                        zone: zone
                    }).invalid) throw new Error("Invalid timezone.");
                    this.zone = zone;
                }
                void 0 !== utcOffset && (this.utcOffset = utcOffset);
                const that = this;
                TIME_UNITS.forEach(timeUnit => {
                    that[timeUnit] = {};
                }), this.source instanceof Date || this.source instanceof luxon.DateTime ? (this.source instanceof Date && (this.source = luxon.DateTime.fromJSDate(this.source)), this.realDate = !0) : (this._parse(this.source), this._verifyParse());
            }
            return CT.prototype = {
                _verifyParse: function() {
                    var months = Object.keys(this.month), dom = Object.keys(this.dayOfMonth);
                    let ok = !1, lastWrongMonth = NaN;
                    for (let i = 0; i < months.length; i++) {
                        var m = months[i], con = MONTH_CONSTRAINTS[parseInt(m, 10)];
                        for (let j = 0; j < dom.length; j++) dom[j] <= con && (ok = !0);
                        ok || (lastWrongMonth = m, console.warn(`Month '${m}' is limited to '${con}' days.`));
                    }
                    if (!ok) {
                        var notOkCon = MONTH_CONSTRAINTS[parseInt(lastWrongMonth, 10)];
                        for (let k = 0; k < dom.length; k++) {
                            var notOkDay = dom[k];
                            notOkCon < notOkDay && (delete this.dayOfMonth[notOkDay], notOkDay = Number(notOkDay) % notOkCon, this.dayOfMonth[notOkDay] = !0);
                        }
                    }
                },
                sendAt: function(i) {
                    let date = this.realDate ? this.source : luxon.DateTime.local();
                    if (this.zone && (date = date.setZone(this.zone)), void 0 !== this.utcOffset) {
                        var offsetHours = parseInt(60 <= this.utcOffset || this.utcOffset <= -60 ? this.utcOffset / 60 : this.utcOffset), offsetMins = 60 <= this.utcOffset || this.utcOffset <= -60 ? Math.abs(this.utcOffset - 60 * offsetHours) : 0, offsetMins = 10 <= offsetMins ? offsetMins : "0" + offsetMins;
                        let utcZone = "UTC";
                        if (parseInt(this.utcOffset) < 0 ? utcZone += `${0 === offsetHours ? "-0" : offsetHours}:` + offsetMins : utcZone += `+${offsetHours}:` + offsetMins, (date = date.setZone(utcZone)).invalid) throw new Error("ERROR: You specified an invalid UTC offset.");
                    }
                    if (this.realDate) {
                        if (luxon.DateTime.local() > date) throw new Error("WARNING: Date in past. Will never be fired.");
                        return date;
                    }
                    if (isNaN(i) || i < 0) return this._getNextDateFrom(date);
                    for (var dates = []; 0 < i; i--) date = this._getNextDateFrom(date), dates.push(date);
                    return dates;
                },
                getTimeout: function() {
                    return Math.max(-1, this.sendAt() - luxon.DateTime.local());
                },
                toString: function() {
                    return this.toJSON().join(" ");
                },
                toJSON: function() {
                    const self = this;
                    return TIME_UNITS.map(function(timeName) {
                        return self._wcOrAll(timeName);
                    });
                },
                getNextDateFrom: function(start, zone) {
                    return this._getNextDateFrom(start, zone);
                },
                _getNextDateFrom: function(start, zone) {
                    let date = start = start instanceof Date ? luxon.DateTime.fromJSDate(start) : start;
                    var firstDate = start.toMillis();
                    if (zone && (date = date.setZone(zone)), this.realDate || 0 < date.millisecond && (date = date.set({
                        millisecond: 0,
                        second: date.second + 1
                    })), date.invalid) throw new Error("ERROR: You specified an invalid date.");
                    for (var maxMatch = luxon.DateTime.now().plus({
                        years: 8
                    }); ;) {
                        var diff = date - start;
                        if (date > maxMatch) throw new Error(`Something went wrong. No execution date was found in the next 8 years.
							Please provide the following string if you would like to help debug:
							Time Zone: ${zone || '""'} - Cron String: ${this} - UTC offset: ${date.offset}
							- current Date: ` + luxon.DateTime.local().toString());
                        if (date.month - 1 in this.month || 12 === Object.keys(this.month).length) {
                            if (date.day in this.dayOfMonth || 31 === Object.keys(this.dayOfMonth).length || date.getWeekDay() in this.dayOfWeek && 7 !== Object.keys(this.dayOfWeek).length) {
                                if (date.getWeekDay() in this.dayOfWeek || 7 === Object.keys(this.dayOfWeek).length || date.day in this.dayOfMonth && 31 !== Object.keys(this.dayOfMonth).length) if (date.hour in this.hour || 24 === Object.keys(this.hour).length) if (date.minute in this.minute || 60 === Object.keys(this.minute).length) if (date.second in this.second || 60 === Object.keys(this.second).length) {
                                    if (date.toMillis() !== firstDate) break;
                                    {
                                        const expectedSecond = date.second + 1, expectedMinute = date.minute + (60 === expectedSecond), expectedHour = date.hour + (60 === expectedMinute ? 1 : 0);
                                        if (date = date.set({
                                            second: expectedSecond
                                        }), this._forwardDSTJump(expectedHour, expectedMinute, date)) {
                                            const [ done, newDate ] = this._findPreviousDSTJump(date);
                                            if (date = newDate, done) break;
                                        }
                                    }
                                } else {
                                    var expectedSecond = 59 === date.second && 6e4 < diff ? 0 : date.second + 1;
                                    const expectedMinute = date.minute + (60 === expectedSecond), expectedHour = date.hour + (60 === expectedMinute ? 1 : 0);
                                    if (date = date.set({
                                        second: expectedSecond
                                    }), this._forwardDSTJump(expectedHour, expectedMinute, date)) {
                                        const [ done, newDate ] = this._findPreviousDSTJump(date);
                                        if (date = newDate, done) break;
                                    }
                                } else {
                                    const expectedMinute = 59 === date.minute && 36e5 < diff ? 0 : date.minute + 1, expectedHour = date.hour + (60 === expectedMinute ? 1 : 0);
                                    if (date = (date = date.set({
                                        minute: expectedMinute
                                    })).set({
                                        second: 0
                                    }), this._forwardDSTJump(expectedHour, expectedMinute, date)) {
                                        const [ done, newDate ] = this._findPreviousDSTJump(date);
                                        if (date = newDate, done) break;
                                    }
                                } else {
                                    expectedSecond = 23 === date.hour && 864e5 < diff ? 0 : date.hour + 1, diff = date.minute;
                                    if (date = (date = date.set({
                                        hour: expectedSecond
                                    })).set({
                                        minute: 0,
                                        second: 0
                                    }), this._forwardDSTJump(expectedSecond, diff, date)) {
                                        const [ done, newDate ] = this._findPreviousDSTJump(date);
                                        if (date = newDate, done) break;
                                    }
                                } else if (date = (date = date.plus({
                                    days: 1
                                })).set({
                                    hour: 0,
                                    minute: 0,
                                    second: 0
                                }), this._forwardDSTJump(0, 0, date)) {
                                    const [ done, newDate ] = this._findPreviousDSTJump(date);
                                    if (date = newDate, done) break;
                                }
                            } else if (date = (date = date.plus({
                                days: 1
                            })).set({
                                hour: 0,
                                minute: 0,
                                second: 0
                            }), this._forwardDSTJump(0, 0, date)) {
                                const [ done, newDate ] = this._findPreviousDSTJump(date);
                                if (date = newDate, done) break;
                            }
                        } else if (date = (date = date.plus({
                            months: 1
                        })).set({
                            day: 1,
                            hour: 0,
                            minute: 0,
                            second: 0
                        }), this._forwardDSTJump(0, 0, date)) {
                            var [ diff, newDate ] = this._findPreviousDSTJump(date);
                            if (date = newDate, diff) break;
                        }
                    }
                    return date;
                },
                _findPreviousDSTJump: function(date) {
                    let expectedMinute, expectedHour, actualMinute, actualHour, maybeJumpingPoint = date;
                    let iteration = 0;
                    do {
                        if (1440 < ++iteration) throw new Error(`ERROR: This DST checking related function assumes the input DateTime (${date.toISO()}) is within 24 hours of a DST jump.`);
                    } while (expectedMinute = maybeJumpingPoint.minute - 1, expectedHour = maybeJumpingPoint.hour, expectedMinute < 0 && (expectedMinute += 60, expectedHour = (expectedHour + 24 - 1) % 24), actualMinute = (maybeJumpingPoint = maybeJumpingPoint.minus({
                        minute: 1
                    })).minute, actualHour = maybeJumpingPoint.hour, expectedMinute === actualMinute && expectedHour === actualHour);
                    var afterJumpingPoint = maybeJumpingPoint.plus({
                        minute: 1
                    }).set({
                        seconds: 0,
                        millisecond: 0
                    }), beforeJumpingPoint = afterJumpingPoint.minus({
                        second: 1
                    });
                    return date.month in this.month && date.day in this.dayOfMonth && date.getWeekDay() in this.dayOfWeek ? [ this._checkTimeInSkippedRange(beforeJumpingPoint, afterJumpingPoint), afterJumpingPoint ] : [ !1, afterJumpingPoint ];
                },
                _checkTimeInSkippedRange: function(beforeJumpingPoint, afterJumpingPoint) {
                    var startingMinute = (beforeJumpingPoint.minute + 1) % 60, beforeJumpingPoint = (beforeJumpingPoint.hour + (0 == startingMinute)) % 24, hourRangeSize = afterJumpingPoint.hour - beforeJumpingPoint + 1, isHourJump = 0 == startingMinute && 0 === afterJumpingPoint.minute;
                    return 2 == hourRangeSize && isHourJump ? beforeJumpingPoint in this.hour : 1 == hourRangeSize ? beforeJumpingPoint in this.hour && this._checkTimeInSkippedRangeSingleHour(startingMinute, afterJumpingPoint.minute) : this._checkTimeInSkippedRangeMultiHour(beforeJumpingPoint, startingMinute, afterJumpingPoint.hour, afterJumpingPoint.minute);
                },
                _checkTimeInSkippedRangeSingleHour: function(startMinute, endMinute) {
                    for (let minute = startMinute; minute < endMinute; ++minute) if (minute in this.minute) return !0;
                    return endMinute in this.minute && 0 in this.second;
                },
                _checkTimeInSkippedRangeMultiHour: function(startHour, startMinute, endHour, endMinute) {
                    if (endHour <= startHour) throw new Error(`ERROR: This DST checking related function assumes the forward jump starting hour (${startHour}) is less than the end hour (${endHour})`);
                    const firstHourMinuteRange = Array.from({
                        length: 60 - startMinute
                    }, (_, k) => startMinute + k), lastHourMinuteRange = Array.from({
                        length: endMinute
                    }, (_, k) => k), middleHourMinuteRange = Array.from({
                        length: 60
                    }, (_, k) => k);
                    for (let hour = startHour; hour <= endHour; ++hour) if (hour in this.hour) {
                        var forHour = (forHour = hour) === startHour ? firstHourMinuteRange : forHour === endHour ? lastHourMinuteRange : middleHourMinuteRange;
                        for (const minute of forHour) if (minute in this.minute) return !0;
                    }
                    return endHour in this.hour && endMinute in this.minute && 0 in this.second;
                },
                _forwardDSTJump: function(expectedHour, expectedMinute, actualDate) {
                    var actualHour = actualDate.hour, actualDate = actualDate.minute;
                    return expectedHour % 24 < actualHour || expectedMinute % 60 < actualDate;
                },
                _wcOrAll: function(type) {
                    if (this._hasAll(type)) return "*";
                    var all = [];
                    for (const time in this[type]) all.push(time);
                    return all.join(",");
                },
                _hasAll: function(type) {
                    var constraints = CONSTRAINTS[TIME_UNITS.indexOf(type)];
                    for (let i = constraints[0], n = constraints[1]; i < n; i++) if (!(i in this[type])) return !1;
                    return !0;
                },
                _parse: function(source) {
                    var units = (source = (source = (source = source.toLowerCase()) in PRESETS ? PRESETS[source] : source).replace(/[a-z]{1,3}/gi, alias => {
                        if (alias in ALIASES) return ALIASES[alias];
                        throw new Error("Unknown alias: " + alias);
                    })).trim().split(/\s+/);
                    if (units.length < TIME_UNITS_LEN - 1) throw new Error("Too few fields");
                    if (units.length > TIME_UNITS_LEN) throw new Error("Too many fields");
                    var unitsLen = units.length;
                    for (let i = 0; i < TIME_UNITS_LEN; i++) {
                        var cur = units[i - (TIME_UNITS_LEN - unitsLen)] || PARSE_DEFAULTS[i];
                        this._parseField(cur, TIME_UNITS[i], CONSTRAINTS[i]);
                    }
                },
                _parseField: function(value, type, constraints) {
                    const typeObj = this[type];
                    let pointer;
                    const low = constraints[0], high = constraints[1];
                    value.split(",").forEach(field => {
                        var wildcardIndex = field.indexOf("*");
                        if (-1 !== wildcardIndex && 0 !== wildcardIndex) throw new Error(`Field (${field}) has an invalid wildcard expression`);
                    });
                    var allRanges = (value = value.replace(RE_WILDCARDS, low + "-" + high)).split(",");
                    for (let i = 0; i < allRanges.length; i++) {
                        if (!allRanges[i].match(RE_RANGE)) throw new Error(`Field (${type}) cannot be parsed`);
                        allRanges[i].replace(RE_RANGE, ($0, lower, upper, step) => {
                            lower = parseInt(lower, 10), upper = void 0 !== upper ? parseInt(upper, 10) : void 0;
                            var wasStepDefined = !isNaN(parseInt(step, 10));
                            if ("0" === step) throw new Error(`Field (${type}) has a step of zero`);
                            if (step = parseInt(step, 10) || 1, void 0 !== upper && upper < lower) throw new Error(`Field (${type}) has an invalid range`);
                            if (lower < low || void 0 !== upper && upper > high || void 0 === upper && lower > high) throw new Error(`Field value (${value}) is out of range`);
                            for (lower = Math.min(Math.max(low, ~~Math.abs(lower)), high), upper = void 0 !== upper ? Math.min(high, ~~Math.abs(upper)) : wasStepDefined ? high : lower, pointer = lower; typeObj[pointer] = !0, (pointer += step) <= upper; );
                        });
                    }
                }
            }, CT;
        };
    }), _$_empty_2 = createModuleFactory(function(module, exports) {}), _$cron_3 = {};
    root = this, factory = function(luxon, childProcess) {
        const exports = {};
        childProcess = childProcess && childProcess.spawn;
        const CronTime = _$CronTime_5({})(luxon), CronJob = _$CronJob_4({})(CronTime, childProcess);
        return luxon.DateTime.prototype.getWeekDay = function() {
            return 7 === this.weekday ? 0 : this.weekday;
        }, exports.job = (cronTime, onTick, onComplete, startNow, timeZone, context, runOnInit, utcOffset, unrefTimeout) => new CronJob(cronTime, onTick, onComplete, startNow, timeZone, context, runOnInit, utcOffset, unrefTimeout), exports.time = (cronTime, timeZone) => new CronTime(cronTime, timeZone), exports.sendAt = cronTime => exports.time(cronTime).sendAt(), exports.timeout = cronTime => exports.time(cronTime).getTimeout(), exports.CronJob = CronJob, exports.CronTime = CronTime, exports;
    }, "function" == typeof define && define.amd ? define([ "luxon" ], factory) : "object" == typeof _$cron_3 ? _$cron_3 = factory(require(6), _$_empty_2({})) : root.Cron = factory(root.luxon);
    !function(global) {
        !function() {
            "use strict";
            var obj = (obj = _$cron_3) && obj.__esModule ? obj : {
                default: obj
            };
            global.Cron = obj.default;
        }.call(this);
    }.call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
}();
