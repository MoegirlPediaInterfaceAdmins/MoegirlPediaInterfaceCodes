/**
 * Generated by scripts/browserify/index.js
 * Options:
 *     module: "cron"
 *     entry: "Cron"
 *     gadget: { "name": "cron", "fileName": "MediaWiki:Gadget-cron.js" }
 *     namespaceImport: true
 */
!function() {
    var _$_empty_2 = {}, _$errors_4 = {};
    Object.defineProperty(_$errors_4, "__esModule", {
        value: !0
    }), _$errors_4.ExclusiveParametersError = void 0;
    class ExclusiveParametersError extends Error {
        constructor(param1, param2) {
            super(`You can't specify both ${param1} and ` + param2);
        }
    }
    _$errors_4.ExclusiveParametersError = ExclusiveParametersError;
    var _$luxon_9 = {};
    function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, function(arg) {
                arg = function(input, hint) {
                    if ("object" != typeof input || null === input) return input;
                    var prim = input[Symbol.toPrimitive];
                    if (void 0 === prim) return ("string" === hint ? String : Number)(input);
                    prim = prim.call(input, hint || "default");
                    if ("object" != typeof prim) return prim;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }(arg, "string");
                return "symbol" == typeof arg ? arg : String(arg);
            }(descriptor.key), descriptor);
        }
    }
    function _createClass(Constructor, protoProps, staticProps) {
        protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Object.defineProperty(Constructor, "prototype", {
            writable: !1
        });
    }
    function _extends() {
        return (_extends = Object.assign ? Object.assign.bind() : function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var key, source = arguments[i];
                for (key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }).apply(this, arguments);
    }
    function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype), _setPrototypeOf(subClass.prototype.constructor = subClass, superClass);
    }
    function _getPrototypeOf(o) {
        return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(o) {
            return o.__proto__ || Object.getPrototypeOf(o);
        })(o);
    }
    function _setPrototypeOf(o, p) {
        return (_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(o, p) {
            return o.__proto__ = p, o;
        })(o, p);
    }
    function _construct(Parent, args, Class) {
        return (_construct = function() {
            if ("undefined" != typeof Reflect && Reflect.construct && !Reflect.construct.sham) {
                if ("function" == typeof Proxy) return 1;
                try {
                    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), 1;
                } catch (e) {}
            }
        }() ? Reflect.construct.bind() : function(Parent, args, Class) {
            var a = [ null ];
            a.push.apply(a, args);
            args = new (Function.bind.apply(Parent, a))();
            return Class && _setPrototypeOf(args, Class.prototype), args;
        }).apply(null, arguments);
    }
    function _wrapNativeSuper(Class) {
        var _cache = "function" == typeof Map ? new Map() : void 0;
        return (_wrapNativeSuper = function(Class) {
            if (null === Class || -1 === Function.toString.call(Class).indexOf("[native code]")) return Class;
            if ("function" != typeof Class) throw new TypeError("Super expression must either be null or a function");
            if (void 0 !== _cache) {
                if (_cache.has(Class)) return _cache.get(Class);
                _cache.set(Class, Wrapper);
            }
            function Wrapper() {
                return _construct(Class, arguments, _getPrototypeOf(this).constructor);
            }
            return Wrapper.prototype = Object.create(Class.prototype, {
                constructor: {
                    value: Wrapper,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), _setPrototypeOf(Wrapper, Class);
        })(Class);
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
        if (null == source) return {};
        for (var key, target = {}, sourceKeys = Object.keys(source), i = 0; i < sourceKeys.length; i++) key = sourceKeys[i], 0 <= excluded.indexOf(key) || (target[key] = source[key]);
        return target;
    }
    function _arrayLikeToArray(arr, len) {
        (null == len || len > arr.length) && (len = arr.length);
        for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
        return arr2;
    }
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
        var i, it = "undefined" != typeof Symbol && o[Symbol.iterator] || o["@@iterator"];
        if (it) return (it = it.call(o)).next.bind(it);
        if (Array.isArray(o) || (it = function(o, minLen) {
            var n;
            if (o) return "string" == typeof o ? _arrayLikeToArray(o, minLen) : "Map" === (n = "Object" === (n = Object.prototype.toString.call(o).slice(8, -1)) && o.constructor ? o.constructor.name : n) || "Set" === n ? Array.from(o) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? _arrayLikeToArray(o, minLen) : void 0;
        }(o)) || allowArrayLike && o && "number" == typeof o.length) return it && (o = it), i = 0, function() {
            return i >= o.length ? {
                done: !0
            } : {
                done: !1,
                value: o[i++]
            };
        };
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    Object.defineProperty(_$luxon_9, "__esModule", {
        value: !0
    });
    var LuxonError = function(_Error) {
        function LuxonError() {
            return _Error.apply(this, arguments) || this;
        }
        return _inheritsLoose(LuxonError, _Error), LuxonError;
    }(_wrapNativeSuper(Error)), InvalidDateTimeError = function(_LuxonError) {
        function InvalidDateTimeError(reason) {
            return _LuxonError.call(this, "Invalid DateTime: " + reason.toMessage()) || this;
        }
        return _inheritsLoose(InvalidDateTimeError, _LuxonError), InvalidDateTimeError;
    }(LuxonError), InvalidIntervalError = function(_LuxonError2) {
        function InvalidIntervalError(reason) {
            return _LuxonError2.call(this, "Invalid Interval: " + reason.toMessage()) || this;
        }
        return _inheritsLoose(InvalidIntervalError, _LuxonError2), InvalidIntervalError;
    }(LuxonError), InvalidDurationError = function(_LuxonError3) {
        function InvalidDurationError(reason) {
            return _LuxonError3.call(this, "Invalid Duration: " + reason.toMessage()) || this;
        }
        return _inheritsLoose(InvalidDurationError, _LuxonError3), InvalidDurationError;
    }(LuxonError), ConflictingSpecificationError = function(_LuxonError4) {
        function ConflictingSpecificationError() {
            return _LuxonError4.apply(this, arguments) || this;
        }
        return _inheritsLoose(ConflictingSpecificationError, _LuxonError4), ConflictingSpecificationError;
    }(LuxonError), InvalidUnitError = function(_LuxonError5) {
        function InvalidUnitError(unit) {
            return _LuxonError5.call(this, "Invalid unit " + unit) || this;
        }
        return _inheritsLoose(InvalidUnitError, _LuxonError5), InvalidUnitError;
    }(LuxonError), InvalidArgumentError = function(_LuxonError6) {
        function InvalidArgumentError() {
            return _LuxonError6.apply(this, arguments) || this;
        }
        return _inheritsLoose(InvalidArgumentError, _LuxonError6), InvalidArgumentError;
    }(LuxonError), ZoneIsAbstractError = function(_LuxonError7) {
        function ZoneIsAbstractError() {
            return _LuxonError7.call(this, "Zone is an abstract class") || this;
        }
        return _inheritsLoose(ZoneIsAbstractError, _LuxonError7), ZoneIsAbstractError;
    }(LuxonError), LuxonError = "numeric", s = "short", l = "long", DATE_SHORT = {
        year: LuxonError,
        month: LuxonError,
        day: LuxonError
    }, DATE_MED = {
        year: LuxonError,
        month: s,
        day: LuxonError
    }, DATE_MED_WITH_WEEKDAY = {
        year: LuxonError,
        month: s,
        day: LuxonError,
        weekday: s
    }, DATE_FULL = {
        year: LuxonError,
        month: l,
        day: LuxonError
    }, DATE_HUGE = {
        year: LuxonError,
        month: l,
        day: LuxonError,
        weekday: l
    }, TIME_SIMPLE = {
        hour: LuxonError,
        minute: LuxonError
    }, TIME_WITH_SECONDS = {
        hour: LuxonError,
        minute: LuxonError,
        second: LuxonError
    }, TIME_WITH_SHORT_OFFSET = {
        hour: LuxonError,
        minute: LuxonError,
        second: LuxonError,
        timeZoneName: s
    }, TIME_WITH_LONG_OFFSET = {
        hour: LuxonError,
        minute: LuxonError,
        second: LuxonError,
        timeZoneName: l
    }, TIME_24_SIMPLE = {
        hour: LuxonError,
        minute: LuxonError,
        hourCycle: "h23"
    }, TIME_24_WITH_SECONDS = {
        hour: LuxonError,
        minute: LuxonError,
        second: LuxonError,
        hourCycle: "h23"
    }, TIME_24_WITH_SHORT_OFFSET = {
        hour: LuxonError,
        minute: LuxonError,
        second: LuxonError,
        hourCycle: "h23",
        timeZoneName: s
    }, TIME_24_WITH_LONG_OFFSET = {
        hour: LuxonError,
        minute: LuxonError,
        second: LuxonError,
        hourCycle: "h23",
        timeZoneName: l
    }, DATETIME_SHORT = {
        year: LuxonError,
        month: LuxonError,
        day: LuxonError,
        hour: LuxonError,
        minute: LuxonError
    }, DATETIME_SHORT_WITH_SECONDS = {
        year: LuxonError,
        month: LuxonError,
        day: LuxonError,
        hour: LuxonError,
        minute: LuxonError,
        second: LuxonError
    }, DATETIME_MED = {
        year: LuxonError,
        month: s,
        day: LuxonError,
        hour: LuxonError,
        minute: LuxonError
    }, DATETIME_MED_WITH_SECONDS = {
        year: LuxonError,
        month: s,
        day: LuxonError,
        hour: LuxonError,
        minute: LuxonError,
        second: LuxonError
    }, DATETIME_MED_WITH_WEEKDAY = {
        year: LuxonError,
        month: s,
        day: LuxonError,
        weekday: s,
        hour: LuxonError,
        minute: LuxonError
    }, DATETIME_FULL = {
        year: LuxonError,
        month: l,
        day: LuxonError,
        hour: LuxonError,
        minute: LuxonError,
        timeZoneName: s
    }, DATETIME_FULL_WITH_SECONDS = {
        year: LuxonError,
        month: l,
        day: LuxonError,
        hour: LuxonError,
        minute: LuxonError,
        second: LuxonError,
        timeZoneName: s
    }, DATETIME_HUGE = {
        year: LuxonError,
        month: l,
        day: LuxonError,
        weekday: l,
        hour: LuxonError,
        minute: LuxonError,
        timeZoneName: l
    }, DATETIME_HUGE_WITH_SECONDS = {
        year: LuxonError,
        month: l,
        day: LuxonError,
        weekday: l,
        hour: LuxonError,
        minute: LuxonError,
        second: LuxonError,
        timeZoneName: l
    }, Zone = function() {
        function Zone() {}
        var _proto = Zone.prototype;
        return _proto.offsetName = function(ts, opts) {
            throw new ZoneIsAbstractError();
        }, _proto.formatOffset = function(ts, format) {
            throw new ZoneIsAbstractError();
        }, _proto.offset = function(ts) {
            throw new ZoneIsAbstractError();
        }, _proto.equals = function(otherZone) {
            throw new ZoneIsAbstractError();
        }, _createClass(Zone, [ {
            key: "type",
            get: function() {
                throw new ZoneIsAbstractError();
            }
        }, {
            key: "name",
            get: function() {
                throw new ZoneIsAbstractError();
            }
        }, {
            key: "ianaName",
            get: function() {
                return this.name;
            }
        }, {
            key: "isUniversal",
            get: function() {
                throw new ZoneIsAbstractError();
            }
        }, {
            key: "isValid",
            get: function() {
                throw new ZoneIsAbstractError();
            }
        } ]), Zone;
    }(), singleton$1 = null, SystemZone = function(_Zone) {
        function SystemZone() {
            return _Zone.apply(this, arguments) || this;
        }
        _inheritsLoose(SystemZone, _Zone);
        var _proto = SystemZone.prototype;
        return _proto.offsetName = function(ts, _ref) {
            return parseZoneInfo(ts, _ref.format, _ref.locale);
        }, _proto.formatOffset = function(ts, format) {
            return formatOffset(this.offset(ts), format);
        }, _proto.offset = function(ts) {
            return -new Date(ts).getTimezoneOffset();
        }, _proto.equals = function(otherZone) {
            return "system" === otherZone.type;
        }, _createClass(SystemZone, [ {
            key: "type",
            get: function() {
                return "system";
            }
        }, {
            key: "name",
            get: function() {
                return new Intl.DateTimeFormat().resolvedOptions().timeZone;
            }
        }, {
            key: "isUniversal",
            get: function() {
                return !1;
            }
        }, {
            key: "isValid",
            get: function() {
                return !0;
            }
        } ], [ {
            key: "instance",
            get: function() {
                return singleton$1 = null === singleton$1 ? new SystemZone() : singleton$1;
            }
        } ]), SystemZone;
    }(Zone), dtfCache = {};
    var typeToPos = {
        year: 0,
        month: 1,
        day: 2,
        era: 3,
        hour: 4,
        minute: 5,
        second: 6
    };
    var ianaZoneCache = {}, IANAZone = function(_Zone) {
        function IANAZone(name) {
            var _this = _Zone.call(this) || this;
            return _this.zoneName = name, _this.valid = IANAZone.isValidZone(name), _this;
        }
        _inheritsLoose(IANAZone, _Zone), IANAZone.create = function(name) {
            return ianaZoneCache[name] || (ianaZoneCache[name] = new IANAZone(name)), ianaZoneCache[name];
        }, IANAZone.resetCache = function() {
            ianaZoneCache = {}, dtfCache = {};
        }, IANAZone.isValidSpecifier = function(s) {
            return this.isValidZone(s);
        }, IANAZone.isValidZone = function(zone) {
            if (!zone) return !1;
            try {
                return new Intl.DateTimeFormat("en-US", {
                    timeZone: zone
                }).format(), !0;
            } catch (e) {
                return !1;
            }
        };
        var _proto = IANAZone.prototype;
        return _proto.offsetName = function(ts, _ref) {
            return parseZoneInfo(ts, _ref.format, _ref.locale, this.name);
        }, _proto.formatOffset = function(ts, format) {
            return formatOffset(this.offset(ts), format);
        }, _proto.offset = function(ts) {
            var year, month, day, adOrBc, minute, zone, hour, over, ts = new Date(ts);
            return isNaN(ts) ? NaN : (zone = this.name, dtfCache[zone] || (dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
                hour12: !1,
                timeZone: zone,
                year: "numeric",
                month: "2-digit",
                day: "2-digit",
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit",
                era: "short"
            })), year = (zone = ((zone = dtfCache[zone]).formatToParts ? function(dtf, date) {
                for (var formatted = dtf.formatToParts(date), filled = [], i = 0; i < formatted.length; i++) {
                    var _formatted$i = formatted[i], type = _formatted$i.type, _formatted$i = _formatted$i.value, pos = typeToPos[type];
                    "era" === type ? filled[pos] = _formatted$i : void 0 !== pos && (filled[pos] = parseInt(_formatted$i, 10));
                }
                return filled;
            } : function(dtf, date) {
                var dtf = dtf.format(date).replace(/\u200E/g, ""), dtf = (date = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(dtf))[1], fDay = date[2];
                return [ date[3], dtf, fDay, date[4], date[5], date[6], date[7] ];
            })(zone, ts))[0], month = zone[1], day = zone[2], adOrBc = zone[3], hour = zone[4], minute = zone[5], zone = zone[6], hour = 24 === hour ? 0 : hour, over = (ts = +ts) % 1e3, (objToLocalTS({
                year: year = "BC" === adOrBc ? 1 - Math.abs(year) : year,
                month: month,
                day: day,
                hour: hour,
                minute: minute,
                second: zone,
                millisecond: 0
            }) - (ts -= 0 <= over ? over : 1e3 + over)) / 6e4);
        }, _proto.equals = function(otherZone) {
            return "iana" === otherZone.type && otherZone.name === this.name;
        }, _createClass(IANAZone, [ {
            key: "type",
            get: function() {
                return "iana";
            }
        }, {
            key: "name",
            get: function() {
                return this.zoneName;
            }
        }, {
            key: "isUniversal",
            get: function() {
                return !1;
            }
        }, {
            key: "isValid",
            get: function() {
                return this.valid;
            }
        } ]), IANAZone;
    }(Zone), _excluded = [ "base" ], _excluded2 = [ "padTo", "floor" ], intlLFCache = {};
    var intlDTCache = {};
    function getCachedDTF(locString, opts) {
        void 0 === opts && (opts = {});
        var key = JSON.stringify([ locString, opts ]), dtf = intlDTCache[key];
        return dtf || (dtf = new Intl.DateTimeFormat(locString, opts), intlDTCache[key] = dtf), dtf;
    }
    var intlNumCache = {};
    var intlRelCache = {};
    var sysLocaleCache = null;
    function listStuff(loc, length, englishFn, intlFn) {
        loc = loc.listingMode();
        return "error" === loc ? null : ("en" === loc ? englishFn : intlFn)(length);
    }
    var PolyNumberFormatter = function() {
        function PolyNumberFormatter(intl, forceSimple, opts) {
            this.padTo = opts.padTo || 0, this.floor = opts.floor || !1, opts.padTo, opts.floor;
            var otherOpts = _objectWithoutPropertiesLoose(opts, _excluded2);
            (!forceSimple || 0 < Object.keys(otherOpts).length) && (forceSimple = _extends({
                useGrouping: !1
            }, opts), 0 < opts.padTo && (forceSimple.minimumIntegerDigits = opts.padTo), this.inf = function(locString, opts) {
                void 0 === opts && (opts = {});
                var key = JSON.stringify([ locString, opts ]), inf = intlNumCache[key];
                return inf || (inf = new Intl.NumberFormat(locString, opts), intlNumCache[key] = inf), inf;
            }(intl, forceSimple));
        }
        return PolyNumberFormatter.prototype.format = function(i) {
            var fixed;
            return this.inf ? (fixed = this.floor ? Math.floor(i) : i, this.inf.format(fixed)) : padStart(this.floor ? Math.floor(i) : roundTo(i, 3), this.padTo);
        }, PolyNumberFormatter;
    }(), PolyDateFormatter = function() {
        function PolyDateFormatter(dt, intl, opts) {
            this.opts = opts;
            var opts = this.originalZone = void 0, gmtOffset = (this.opts.timeZone ? this.dt = dt : "fixed" === dt.zone.type ? (gmtOffset = 0 <= (gmtOffset = dt.offset / 60 * -1) ? "Etc/GMT+" + gmtOffset : "Etc/GMT" + gmtOffset, 0 !== dt.offset && IANAZone.create(gmtOffset).valid ? (opts = gmtOffset, this.dt = dt) : (opts = "UTC", this.dt = 0 === dt.offset ? dt : dt.setZone("UTC").plus({
                minutes: dt.offset
            }), this.originalZone = dt.zone)) : "system" === dt.zone.type ? this.dt = dt : "iana" === dt.zone.type ? opts = (this.dt = dt).zone.name : (this.dt = dt.setZone(opts = "UTC").plus({
                minutes: dt.offset
            }), this.originalZone = dt.zone), _extends({}, this.opts));
            gmtOffset.timeZone = gmtOffset.timeZone || opts, this.dtf = getCachedDTF(intl, gmtOffset);
        }
        var _proto2 = PolyDateFormatter.prototype;
        return _proto2.format = function() {
            return this.originalZone ? this.formatToParts().map(function(_ref) {
                return _ref.value;
            }).join("") : this.dtf.format(this.dt.toJSDate());
        }, _proto2.formatToParts = function() {
            var _this = this, parts = this.dtf.formatToParts(this.dt.toJSDate());
            return this.originalZone ? parts.map(function(part) {
                return "timeZoneName" === part.type ? _extends({}, part, {
                    value: _this.originalZone.offsetName(_this.dt.ts, {
                        locale: _this.dt.locale,
                        format: _this.opts.timeZoneName
                    })
                }) : part;
            }) : parts;
        }, _proto2.resolvedOptions = function() {
            return this.dtf.resolvedOptions();
        }, PolyDateFormatter;
    }(), PolyRelFormatter = function() {
        function PolyRelFormatter(intl, isEnglish, opts) {
            this.opts = _extends({
                style: "long"
            }, opts), !isEnglish && hasRelative() && (this.rtf = function(locString, opts) {
                (_opts = opts = void 0 === opts ? {} : opts).base;
                var _opts = _objectWithoutPropertiesLoose(_opts = opts, _excluded), _opts = JSON.stringify([ locString, _opts ]), inf = intlRelCache[_opts];
                return inf || (inf = new Intl.RelativeTimeFormat(locString, opts), intlRelCache[_opts] = inf), inf;
            }(intl, opts));
        }
        var _proto3 = PolyRelFormatter.prototype;
        return _proto3.format = function(count, unit) {
            return this.rtf ? this.rtf.format(count, unit) : function(unit, count, numeric, narrow) {
                void 0 === numeric && (numeric = "always");
                void 0 === narrow && (narrow = !1);
                var units = {
                    years: [ "year", "yr." ],
                    quarters: [ "quarter", "qtr." ],
                    months: [ "month", "mo." ],
                    weeks: [ "week", "wk." ],
                    days: [ "day", "day", "days" ],
                    hours: [ "hour", "hr." ],
                    minutes: [ "minute", "min." ],
                    seconds: [ "second", "sec." ]
                }, lastable = -1 === [ "hours", "minutes", "seconds" ].indexOf(unit);
                if ("auto" === numeric && lastable) {
                    var isDay = "days" === unit;
                    switch (count) {
                      case 1:
                        return isDay ? "tomorrow" : "next " + units[unit][0];

                      case -1:
                        return isDay ? "yesterday" : "last " + units[unit][0];

                      case 0:
                        return isDay ? "today" : "this " + units[unit][0];
                    }
                }
                var numeric = Object.is(count, -0) || count < 0, lastable = Math.abs(count), count = 1 === lastable, lilUnits = units[unit], narrow = narrow ? !count && lilUnits[2] || lilUnits[1] : count ? units[unit][0] : unit;
                return numeric ? lastable + " " + narrow + " ago" : "in " + lastable + " " + narrow;
            }(unit, count, this.opts.numeric, "long" !== this.opts.style);
        }, _proto3.formatToParts = function(count, unit) {
            return this.rtf ? this.rtf.formatToParts(count, unit) : [];
        }, PolyRelFormatter;
    }(), Locale = function() {
        function Locale(locale, numbering, outputCalendar, specifiedLocale) {
            var locale = function(localeStr) {
                var xIndex = localeStr.indexOf("-x-");
                if (-1 === (xIndex = (localeStr = -1 !== xIndex ? localeStr.substring(0, xIndex) : localeStr).indexOf("-u-"))) return [ localeStr ];
                try {
                    options = getCachedDTF(localeStr).resolvedOptions(), selectedStr = localeStr;
                } catch (e) {
                    var localeStr = localeStr.substring(0, xIndex), options = getCachedDTF(localeStr).resolvedOptions(), selectedStr = localeStr;
                }
                return [ selectedStr, (xIndex = options).numberingSystem, xIndex.calendar ];
            }(locale), parsedLocale = locale[0], parsedNumberingSystem = locale[1], locale = locale[2];
            this.locale = parsedLocale, this.numberingSystem = numbering || parsedNumberingSystem || null, this.outputCalendar = outputCalendar || locale || null, this.intl = function(localeStr, numberingSystem, outputCalendar) {
                return (outputCalendar || numberingSystem) && (localeStr.includes("-u-") || (localeStr += "-u"), outputCalendar && (localeStr += "-ca-" + outputCalendar), numberingSystem) && (localeStr += "-nu-" + numberingSystem), localeStr;
            }(this.locale, this.numberingSystem, this.outputCalendar), this.weekdaysCache = {
                format: {},
                standalone: {}
            }, this.monthsCache = {
                format: {},
                standalone: {}
            }, this.meridiemCache = null, this.eraCache = {}, this.specifiedLocale = specifiedLocale, this.fastNumbersCached = null;
        }
        Locale.fromOpts = function(opts) {
            return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);
        }, Locale.create = function(locale, numberingSystem, outputCalendar, defaultToEN) {
            void 0 === defaultToEN && (defaultToEN = !1);
            locale = locale || Settings.defaultLocale;
            return new Locale(locale || (defaultToEN ? "en-US" : sysLocaleCache = sysLocaleCache || new Intl.DateTimeFormat().resolvedOptions().locale), numberingSystem || Settings.defaultNumberingSystem, outputCalendar || Settings.defaultOutputCalendar, locale);
        }, Locale.resetCache = function() {
            sysLocaleCache = null, intlDTCache = {}, intlNumCache = {}, intlRelCache = {};
        }, Locale.fromObject = function(_temp) {
            var _temp = void 0 === _temp ? {} : _temp, locale = _temp.locale, numberingSystem = _temp.numberingSystem, _temp = _temp.outputCalendar;
            return Locale.create(locale, numberingSystem, _temp);
        };
        var _proto4 = Locale.prototype;
        return _proto4.listingMode = function() {
            var isActuallyEn = this.isEnglish(), hasNoWeirdness = !(null !== this.numberingSystem && "latn" !== this.numberingSystem || null !== this.outputCalendar && "gregory" !== this.outputCalendar);
            return isActuallyEn && hasNoWeirdness ? "en" : "intl";
        }, _proto4.clone = function(alts) {
            return alts && 0 !== Object.getOwnPropertyNames(alts).length ? Locale.create(alts.locale || this.specifiedLocale, alts.numberingSystem || this.numberingSystem, alts.outputCalendar || this.outputCalendar, alts.defaultToEN || !1) : this;
        }, _proto4.redefaultToEN = function(alts) {
            return this.clone(_extends({}, alts = void 0 === alts ? {} : alts, {
                defaultToEN: !0
            }));
        }, _proto4.redefaultToSystem = function(alts) {
            return this.clone(_extends({}, alts = void 0 === alts ? {} : alts, {
                defaultToEN: !1
            }));
        }, _proto4.months = function(length, format) {
            var _this2 = this;
            return void 0 === format && (format = !1), listStuff(this, length, months, function() {
                var intl = format ? {
                    month: length,
                    day: "numeric"
                } : {
                    month: length
                }, formatStr = format ? "format" : "standalone";
                return _this2.monthsCache[formatStr][length] || (_this2.monthsCache[formatStr][length] = function(f) {
                    for (var ms = [], i = 1; i <= 12; i++) {
                        var dt = DateTime.utc(2009, i, 1);
                        ms.push(f(dt));
                    }
                    return ms;
                }(function(dt) {
                    return _this2.extract(dt, intl, "month");
                })), _this2.monthsCache[formatStr][length];
            });
        }, _proto4.weekdays = function(length, format) {
            var _this3 = this;
            return void 0 === format && (format = !1), listStuff(this, length, weekdays, function() {
                var intl = format ? {
                    weekday: length,
                    year: "numeric",
                    month: "long",
                    day: "numeric"
                } : {
                    weekday: length
                }, formatStr = format ? "format" : "standalone";
                return _this3.weekdaysCache[formatStr][length] || (_this3.weekdaysCache[formatStr][length] = function(f) {
                    for (var ms = [], i = 1; i <= 7; i++) {
                        var dt = DateTime.utc(2016, 11, 13 + i);
                        ms.push(f(dt));
                    }
                    return ms;
                }(function(dt) {
                    return _this3.extract(dt, intl, "weekday");
                })), _this3.weekdaysCache[formatStr][length];
            });
        }, _proto4.meridiems = function() {
            var _this4 = this;
            return listStuff(this, void 0, function() {
                return meridiems;
            }, function() {
                var intl;
                return _this4.meridiemCache || (intl = {
                    hour: "numeric",
                    hourCycle: "h12"
                }, _this4.meridiemCache = [ DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19) ].map(function(dt) {
                    return _this4.extract(dt, intl, "dayperiod");
                })), _this4.meridiemCache;
            });
        }, _proto4.eras = function(length) {
            var _this5 = this;
            return listStuff(this, length, eras, function() {
                var intl = {
                    era: length
                };
                return _this5.eraCache[length] || (_this5.eraCache[length] = [ DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1) ].map(function(dt) {
                    return _this5.extract(dt, intl, "era");
                })), _this5.eraCache[length];
            });
        }, _proto4.extract = function(dt, intlOpts, field) {
            dt = this.dtFormatter(dt, intlOpts).formatToParts().find(function(m) {
                return m.type.toLowerCase() === field;
            });
            return dt ? dt.value : null;
        }, _proto4.numberFormatter = function(opts) {
            return new PolyNumberFormatter(this.intl, (opts = void 0 === opts ? {} : opts).forceSimple || this.fastNumbers, opts);
        }, _proto4.dtFormatter = function(dt, intlOpts) {
            return new PolyDateFormatter(dt, this.intl, intlOpts = void 0 === intlOpts ? {} : intlOpts);
        }, _proto4.relFormatter = function(opts) {
            return void 0 === opts && (opts = {}), new PolyRelFormatter(this.intl, this.isEnglish(), opts);
        }, _proto4.listFormatter = function(opts) {
            return function(locString, opts) {
                void 0 === opts && (opts = {});
                var key = JSON.stringify([ locString, opts ]), dtf = intlLFCache[key];
                return dtf || (dtf = new Intl.ListFormat(locString, opts), intlLFCache[key] = dtf), dtf;
            }(this.intl, opts = void 0 === opts ? {} : opts);
        }, _proto4.isEnglish = function() {
            return "en" === this.locale || "en-us" === this.locale.toLowerCase() || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
        }, _proto4.equals = function(other) {
            return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
        }, _createClass(Locale, [ {
            key: "fastNumbers",
            get: function() {
                var loc;
                return null == this.fastNumbersCached && (this.fastNumbersCached = (!(loc = this).numberingSystem || "latn" === loc.numberingSystem) && ("latn" === loc.numberingSystem || !loc.locale || loc.locale.startsWith("en") || "latn" === new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem)), this.fastNumbersCached;
            }
        } ]), Locale;
    }(), singleton = null, FixedOffsetZone = function(_Zone) {
        function FixedOffsetZone(offset) {
            var _this = _Zone.call(this) || this;
            return _this.fixed = offset, _this;
        }
        _inheritsLoose(FixedOffsetZone, _Zone), FixedOffsetZone.instance = function(offset) {
            return 0 === offset ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset);
        }, FixedOffsetZone.parseSpecifier = function(s) {
            if (s) {
                s = s.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
                if (s) return new FixedOffsetZone(signedOffset(s[1], s[2]));
            }
            return null;
        };
        var _proto = FixedOffsetZone.prototype;
        return _proto.offsetName = function() {
            return this.name;
        }, _proto.formatOffset = function(ts, format) {
            return formatOffset(this.fixed, format);
        }, _proto.offset = function() {
            return this.fixed;
        }, _proto.equals = function(otherZone) {
            return "fixed" === otherZone.type && otherZone.fixed === this.fixed;
        }, _createClass(FixedOffsetZone, [ {
            key: "type",
            get: function() {
                return "fixed";
            }
        }, {
            key: "name",
            get: function() {
                return 0 === this.fixed ? "UTC" : "UTC" + formatOffset(this.fixed, "narrow");
            }
        }, {
            key: "ianaName",
            get: function() {
                return 0 === this.fixed ? "Etc/UTC" : "Etc/GMT" + formatOffset(-this.fixed, "narrow");
            }
        }, {
            key: "isUniversal",
            get: function() {
                return !0;
            }
        }, {
            key: "isValid",
            get: function() {
                return !0;
            }
        } ], [ {
            key: "utcInstance",
            get: function() {
                return singleton = null === singleton ? new FixedOffsetZone(0) : singleton;
            }
        } ]), FixedOffsetZone;
    }(Zone), InvalidZone = function(_Zone) {
        function InvalidZone(zoneName) {
            var _this = _Zone.call(this) || this;
            return _this.zoneName = zoneName, _this;
        }
        _inheritsLoose(InvalidZone, _Zone);
        var _proto = InvalidZone.prototype;
        return _proto.offsetName = function() {
            return null;
        }, _proto.formatOffset = function() {
            return "";
        }, _proto.offset = function() {
            return NaN;
        }, _proto.equals = function() {
            return !1;
        }, _createClass(InvalidZone, [ {
            key: "type",
            get: function() {
                return "invalid";
            }
        }, {
            key: "name",
            get: function() {
                return this.zoneName;
            }
        }, {
            key: "isUniversal",
            get: function() {
                return !1;
            }
        }, {
            key: "isValid",
            get: function() {
                return !1;
            }
        } ]), InvalidZone;
    }(Zone);
    function normalizeZone(input, defaultZone) {
        var lowered;
        return null == input ? defaultZone : input instanceof Zone ? input : "string" == typeof input ? "default" === (lowered = input.toLowerCase()) ? defaultZone : "local" === lowered || "system" === lowered ? SystemZone.instance : "utc" === lowered || "gmt" === lowered ? FixedOffsetZone.utcInstance : FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input) : isNumber(input) ? FixedOffsetZone.instance(input) : "object" == typeof input && "offset" in input && "function" == typeof input.offset ? input : new InvalidZone(input);
    }
    var throwOnInvalid, now = function() {
        return Date.now();
    }, defaultZone = "system", defaultLocale = null, defaultNumberingSystem = null, defaultOutputCalendar = null, twoDigitCutoffYear = 60, Settings = function() {
        function Settings() {}
        return Settings.resetCaches = function() {
            Locale.resetCache(), IANAZone.resetCache();
        }, _createClass(Settings, null, [ {
            key: "now",
            get: function() {
                return now;
            },
            set: function(n) {
                now = n;
            }
        }, {
            key: "defaultZone",
            get: function() {
                return normalizeZone(defaultZone, SystemZone.instance);
            },
            set: function(zone) {
                defaultZone = zone;
            }
        }, {
            key: "defaultLocale",
            get: function() {
                return defaultLocale;
            },
            set: function(locale) {
                defaultLocale = locale;
            }
        }, {
            key: "defaultNumberingSystem",
            get: function() {
                return defaultNumberingSystem;
            },
            set: function(numberingSystem) {
                defaultNumberingSystem = numberingSystem;
            }
        }, {
            key: "defaultOutputCalendar",
            get: function() {
                return defaultOutputCalendar;
            },
            set: function(outputCalendar) {
                defaultOutputCalendar = outputCalendar;
            }
        }, {
            key: "twoDigitCutoffYear",
            get: function() {
                return twoDigitCutoffYear;
            },
            set: function(cutoffYear) {
                twoDigitCutoffYear = cutoffYear % 100;
            }
        }, {
            key: "throwOnInvalid",
            get: function() {
                return throwOnInvalid;
            },
            set: function(t) {
                throwOnInvalid = t;
            }
        } ]), Settings;
    }();
    function isNumber(o) {
        return "number" == typeof o;
    }
    function isInteger(o) {
        return "number" == typeof o && o % 1 == 0;
    }
    function hasRelative() {
        try {
            return "undefined" != typeof Intl && !!Intl.RelativeTimeFormat;
        } catch (e) {
            return !1;
        }
    }
    function bestBy(arr, by, compare) {
        if (0 !== arr.length) return arr.reduce(function(best, next) {
            next = [ by(next), next ];
            return best && compare(best[0], next[0]) === best[0] ? best : next;
        }, null)[1];
    }
    function hasOwnProperty(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    function integerBetween(thing, bottom, top) {
        return isInteger(thing) && bottom <= thing && thing <= top;
    }
    function padStart(input, n) {
        void 0 === n && (n = 2);
        input = input < 0 ? "-" + ("" + -input).padStart(n, "0") : ("" + input).padStart(n, "0");
        return input;
    }
    function parseInteger(string) {
        if (null != string && "" !== string) return parseInt(string, 10);
    }
    function parseFloating(string) {
        if (null != string && "" !== string) return parseFloat(string);
    }
    function parseMillis(fraction) {
        if (null != fraction && "" !== fraction) return fraction = 1e3 * parseFloat("0." + fraction), Math.floor(fraction);
    }
    function roundTo(number, digits, towardZero) {
        void 0 === towardZero && (towardZero = !1);
        digits = Math.pow(10, digits);
        return (towardZero ? Math.trunc : Math.round)(number * digits) / digits;
    }
    function isLeapYear(year) {
        return year % 4 == 0 && (year % 100 != 0 || year % 400 == 0);
    }
    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }
    function daysInMonth(year, month) {
        var n, x = (x = month - 1) - (n = 12) * Math.floor(x / n) + 1;
        return 2 == x ? isLeapYear(year + (month - x) / 12) ? 29 : 28 : [ 31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ][x - 1];
    }
    function objToLocalTS(obj) {
        var d = Date.UTC(obj.year, obj.month - 1, obj.day, obj.hour, obj.minute, obj.second, obj.millisecond);
        return obj.year < 100 && 0 <= obj.year && (d = new Date(d)).setUTCFullYear(obj.year, obj.month - 1, obj.day), +d;
    }
    function weeksInWeekYear(weekYear) {
        var p1 = (weekYear + Math.floor(weekYear / 4) - Math.floor(weekYear / 100) + Math.floor(weekYear / 400)) % 7, weekYear = weekYear - 1, weekYear = (weekYear + Math.floor(weekYear / 4) - Math.floor(weekYear / 100) + Math.floor(weekYear / 400)) % 7;
        return 4 == p1 || 3 == weekYear ? 53 : 52;
    }
    function untruncateYear(year) {
        return 99 < year ? year : year > Settings.twoDigitCutoffYear ? 1900 + year : 2e3 + year;
    }
    function parseZoneInfo(ts, offsetFormat, locale, timeZone) {
        void 0 === timeZone && (timeZone = null);
        var ts = new Date(ts), intlOpts = {
            hourCycle: "h23",
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit"
        }, timeZone = (timeZone && (intlOpts.timeZone = timeZone), _extends({
            timeZoneName: offsetFormat
        }, intlOpts)), offsetFormat = new Intl.DateTimeFormat(locale, timeZone).formatToParts(ts).find(function(m) {
            return "timezonename" === m.type.toLowerCase();
        });
        return offsetFormat ? offsetFormat.value : null;
    }
    function signedOffset(offHourStr, offMinuteStr) {
        offHourStr = parseInt(offHourStr, 10), Number.isNaN(offHourStr) && (offHourStr = 0), offMinuteStr = parseInt(offMinuteStr, 10) || 0;
        return 60 * offHourStr + (offHourStr < 0 || Object.is(offHourStr, -0) ? -offMinuteStr : offMinuteStr);
    }
    function asNumber(value) {
        var numericValue = Number(value);
        if ("boolean" == typeof value || "" === value || Number.isNaN(numericValue)) throw new InvalidArgumentError("Invalid unit value " + value);
        return numericValue;
    }
    function normalizeObject(obj, normalizer) {
        var u, v, normalized = {};
        for (u in obj) hasOwnProperty(obj, u) && null != (v = obj[u]) && (normalized[normalizer(u)] = asNumber(v));
        return normalized;
    }
    function formatOffset(offset, format) {
        var hours = Math.trunc(Math.abs(offset / 60)), minutes = Math.trunc(Math.abs(offset % 60)), sign = 0 <= offset ? "+" : "-";
        switch (format) {
          case "short":
            return sign + padStart(hours, 2) + ":" + padStart(minutes, 2);

          case "narrow":
            return sign + hours + (0 < minutes ? ":" + minutes : "");

          case "techie":
            return sign + padStart(hours, 2) + padStart(minutes, 2);

          default:
            throw new RangeError("Value format " + format + " is out of range for property format");
        }
    }
    function timeObject(obj) {
        return function(obj, keys) {
            return keys.reduce(function(a, k) {
                return a[k] = obj[k], a;
            }, {});
        }(obj, [ "hour", "minute", "second", "millisecond" ]);
    }
    var monthsLong = [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ], monthsShort = [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ], monthsNarrow = [ "J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D" ];
    function months(length) {
        switch (length) {
          case "narrow":
            return [].concat(monthsNarrow);

          case "short":
            return [].concat(monthsShort);

          case "long":
            return [].concat(monthsLong);

          case "numeric":
            return [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12" ];

          case "2-digit":
            return [ "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12" ];

          default:
            return null;
        }
    }
    var weekdaysLong = [ "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday" ], weekdaysShort = [ "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun" ], weekdaysNarrow = [ "M", "T", "W", "T", "F", "S", "S" ];
    function weekdays(length) {
        switch (length) {
          case "narrow":
            return [].concat(weekdaysNarrow);

          case "short":
            return [].concat(weekdaysShort);

          case "long":
            return [].concat(weekdaysLong);

          case "numeric":
            return [ "1", "2", "3", "4", "5", "6", "7" ];

          default:
            return null;
        }
    }
    var meridiems = [ "AM", "PM" ], erasLong = [ "Before Christ", "Anno Domini" ], erasShort = [ "BC", "AD" ], erasNarrow = [ "B", "A" ];
    function eras(length) {
        switch (length) {
          case "narrow":
            return [].concat(erasNarrow);

          case "short":
            return [].concat(erasShort);

          case "long":
            return [].concat(erasLong);

          default:
            return null;
        }
    }
    function stringifyTokens(splits, tokenToString) {
        for (var s = "", _iterator = _createForOfIteratorHelperLoose(splits); !(_step = _iterator()).done; ) {
            var _step = _step.value;
            _step.literal ? s += _step.val : s += tokenToString(_step.val);
        }
        return s;
    }
    var _macroTokenToFormatOpts = {
        D: DATE_SHORT,
        DD: DATE_MED,
        DDD: DATE_FULL,
        DDDD: DATE_HUGE,
        t: TIME_SIMPLE,
        tt: TIME_WITH_SECONDS,
        ttt: TIME_WITH_SHORT_OFFSET,
        tttt: TIME_WITH_LONG_OFFSET,
        T: TIME_24_SIMPLE,
        TT: TIME_24_WITH_SECONDS,
        TTT: TIME_24_WITH_SHORT_OFFSET,
        TTTT: TIME_24_WITH_LONG_OFFSET,
        f: DATETIME_SHORT,
        ff: DATETIME_MED,
        fff: DATETIME_FULL,
        ffff: DATETIME_HUGE,
        F: DATETIME_SHORT_WITH_SECONDS,
        FF: DATETIME_MED_WITH_SECONDS,
        FFF: DATETIME_FULL_WITH_SECONDS,
        FFFF: DATETIME_HUGE_WITH_SECONDS
    }, Formatter = function() {
        function Formatter(locale, formatOpts) {
            this.opts = formatOpts, this.loc = locale, this.systemLoc = null;
        }
        Formatter.create = function(locale, opts) {
            return new Formatter(locale, opts = void 0 === opts ? {} : opts);
        }, Formatter.parseFormat = function(fmt) {
            for (var current = null, currentFull = "", bracketed = !1, splits = [], i = 0; i < fmt.length; i++) {
                var c = fmt.charAt(i);
                "'" === c ? (0 < currentFull.length && splits.push({
                    literal: bracketed || /^\s+$/.test(currentFull),
                    val: currentFull
                }), current = null, currentFull = "", bracketed = !bracketed) : bracketed || c === current ? currentFull += c : (0 < currentFull.length && splits.push({
                    literal: /^\s+$/.test(currentFull),
                    val: currentFull
                }), current = currentFull = c);
            }
            return 0 < currentFull.length && splits.push({
                literal: bracketed || /^\s+$/.test(currentFull),
                val: currentFull
            }), splits;
        }, Formatter.macroTokenToFormatOpts = function(token) {
            return _macroTokenToFormatOpts[token];
        };
        var _proto = Formatter.prototype;
        return _proto.formatWithSystemDefault = function(dt, opts) {
            return null === this.systemLoc && (this.systemLoc = this.loc.redefaultToSystem()), this.systemLoc.dtFormatter(dt, _extends({}, this.opts, opts)).format();
        }, _proto.dtFormatter = function(dt, opts) {
            return this.loc.dtFormatter(dt, _extends({}, this.opts, opts = void 0 === opts ? {} : opts));
        }, _proto.formatDateTime = function(dt, opts) {
            return this.dtFormatter(dt, opts).format();
        }, _proto.formatDateTimeParts = function(dt, opts) {
            return this.dtFormatter(dt, opts).formatToParts();
        }, _proto.formatInterval = function(interval, opts) {
            return this.dtFormatter(interval.start, opts).dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());
        }, _proto.resolvedOptions = function(dt, opts) {
            return this.dtFormatter(dt, opts).resolvedOptions();
        }, _proto.num = function(n, p) {
            var opts;
            return void 0 === p && (p = 0), this.opts.forceSimple ? padStart(n, p) : (opts = _extends({}, this.opts), 0 < p && (opts.padTo = p), this.loc.numberFormatter(opts).format(n));
        }, _proto.formatDateTimeFromString = function(dt, fmt) {
            var _this = this, knownEnglish = "en" === this.loc.listingMode(), useDateTimeFormatter = this.loc.outputCalendar && "gregory" !== this.loc.outputCalendar, string = function(opts, extract) {
                return _this.loc.extract(dt, opts, extract);
            }, formatOffset = function(opts) {
                return dt.isOffsetFixed && 0 === dt.offset && opts.allowZ ? "Z" : dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
            }, meridiem = function() {
                return knownEnglish ? function(dt) {
                    return meridiems[dt.hour < 12 ? 0 : 1];
                }(dt) : string({
                    hour: "numeric",
                    hourCycle: "h12"
                }, "dayperiod");
            }, month = function(length, standalone) {
                return knownEnglish ? function(dt, length) {
                    return months(length)[dt.month - 1];
                }(dt, length) : string(standalone ? {
                    month: length
                } : {
                    month: length,
                    day: "numeric"
                }, "month");
            }, weekday = function(length, standalone) {
                return knownEnglish ? function(dt, length) {
                    return weekdays(length)[dt.weekday - 1];
                }(dt, length) : string(standalone ? {
                    weekday: length
                } : {
                    weekday: length,
                    month: "long",
                    day: "numeric"
                }, "weekday");
            }, maybeMacro = function(token) {
                var formatOpts = Formatter.macroTokenToFormatOpts(token);
                return formatOpts ? _this.formatWithSystemDefault(dt, formatOpts) : token;
            }, era = function(length) {
                return knownEnglish ? function(dt, length) {
                    return eras(length)[dt.year < 0 ? 0 : 1];
                }(dt, length) : string({
                    era: length
                }, "era");
            };
            return stringifyTokens(Formatter.parseFormat(fmt), function(token) {
                switch (token) {
                  case "S":
                    return _this.num(dt.millisecond);

                  case "u":
                  case "SSS":
                    return _this.num(dt.millisecond, 3);

                  case "s":
                    return _this.num(dt.second);

                  case "ss":
                    return _this.num(dt.second, 2);

                  case "uu":
                    return _this.num(Math.floor(dt.millisecond / 10), 2);

                  case "uuu":
                    return _this.num(Math.floor(dt.millisecond / 100));

                  case "m":
                    return _this.num(dt.minute);

                  case "mm":
                    return _this.num(dt.minute, 2);

                  case "h":
                    return _this.num(dt.hour % 12 == 0 ? 12 : dt.hour % 12);

                  case "hh":
                    return _this.num(dt.hour % 12 == 0 ? 12 : dt.hour % 12, 2);

                  case "H":
                    return _this.num(dt.hour);

                  case "HH":
                    return _this.num(dt.hour, 2);

                  case "Z":
                    return formatOffset({
                        format: "narrow",
                        allowZ: _this.opts.allowZ
                    });

                  case "ZZ":
                    return formatOffset({
                        format: "short",
                        allowZ: _this.opts.allowZ
                    });

                  case "ZZZ":
                    return formatOffset({
                        format: "techie",
                        allowZ: _this.opts.allowZ
                    });

                  case "ZZZZ":
                    return dt.zone.offsetName(dt.ts, {
                        format: "short",
                        locale: _this.loc.locale
                    });

                  case "ZZZZZ":
                    return dt.zone.offsetName(dt.ts, {
                        format: "long",
                        locale: _this.loc.locale
                    });

                  case "z":
                    return dt.zoneName;

                  case "a":
                    return meridiem();

                  case "d":
                    return useDateTimeFormatter ? string({
                        day: "numeric"
                    }, "day") : _this.num(dt.day);

                  case "dd":
                    return useDateTimeFormatter ? string({
                        day: "2-digit"
                    }, "day") : _this.num(dt.day, 2);

                  case "c":
                    return _this.num(dt.weekday);

                  case "ccc":
                    return weekday("short", !0);

                  case "cccc":
                    return weekday("long", !0);

                  case "ccccc":
                    return weekday("narrow", !0);

                  case "E":
                    return _this.num(dt.weekday);

                  case "EEE":
                    return weekday("short", !1);

                  case "EEEE":
                    return weekday("long", !1);

                  case "EEEEE":
                    return weekday("narrow", !1);

                  case "L":
                    return useDateTimeFormatter ? string({
                        month: "numeric",
                        day: "numeric"
                    }, "month") : _this.num(dt.month);

                  case "LL":
                    return useDateTimeFormatter ? string({
                        month: "2-digit",
                        day: "numeric"
                    }, "month") : _this.num(dt.month, 2);

                  case "LLL":
                    return month("short", !0);

                  case "LLLL":
                    return month("long", !0);

                  case "LLLLL":
                    return month("narrow", !0);

                  case "M":
                    return useDateTimeFormatter ? string({
                        month: "numeric"
                    }, "month") : _this.num(dt.month);

                  case "MM":
                    return useDateTimeFormatter ? string({
                        month: "2-digit"
                    }, "month") : _this.num(dt.month, 2);

                  case "MMM":
                    return month("short", !1);

                  case "MMMM":
                    return month("long", !1);

                  case "MMMMM":
                    return month("narrow", !1);

                  case "y":
                    return useDateTimeFormatter ? string({
                        year: "numeric"
                    }, "year") : _this.num(dt.year);

                  case "yy":
                    return useDateTimeFormatter ? string({
                        year: "2-digit"
                    }, "year") : _this.num(dt.year.toString().slice(-2), 2);

                  case "yyyy":
                    return useDateTimeFormatter ? string({
                        year: "numeric"
                    }, "year") : _this.num(dt.year, 4);

                  case "yyyyyy":
                    return useDateTimeFormatter ? string({
                        year: "numeric"
                    }, "year") : _this.num(dt.year, 6);

                  case "G":
                    return era("short");

                  case "GG":
                    return era("long");

                  case "GGGGG":
                    return era("narrow");

                  case "kk":
                    return _this.num(dt.weekYear.toString().slice(-2), 2);

                  case "kkkk":
                    return _this.num(dt.weekYear, 4);

                  case "W":
                    return _this.num(dt.weekNumber);

                  case "WW":
                    return _this.num(dt.weekNumber, 2);

                  case "o":
                    return _this.num(dt.ordinal);

                  case "ooo":
                    return _this.num(dt.ordinal, 3);

                  case "q":
                    return _this.num(dt.quarter);

                  case "qq":
                    return _this.num(dt.quarter, 2);

                  case "X":
                    return _this.num(Math.floor(dt.ts / 1e3));

                  case "x":
                    return _this.num(dt.ts);

                  default:
                    return maybeMacro(token);
                }
            });
        }, _proto.formatDurationFromString = function(dur, fmt) {
            var lildur, _this2 = this, tokenToField = function(token) {
                switch (token[0]) {
                  case "S":
                    return "millisecond";

                  case "s":
                    return "second";

                  case "m":
                    return "minute";

                  case "h":
                    return "hour";

                  case "d":
                    return "day";

                  case "w":
                    return "week";

                  case "M":
                    return "month";

                  case "y":
                    return "year";

                  default:
                    return null;
                }
            }, fmt = Formatter.parseFormat(fmt), realTokens = fmt.reduce(function(found, _ref) {
                var literal = _ref.literal, _ref = _ref.val;
                return literal ? found : found.concat(_ref);
            }, []), dur = dur.shiftTo.apply(dur, realTokens.map(tokenToField).filter(function(t) {
                return t;
            }));
            return stringifyTokens(fmt, (lildur = dur, function(token) {
                var mapped = tokenToField(token);
                return mapped ? _this2.num(lildur.get(mapped), token.length) : token;
            }));
        }, Formatter;
    }(), Invalid = function() {
        function Invalid(reason, explanation) {
            this.reason = reason, this.explanation = explanation;
        }
        return Invalid.prototype.toMessage = function() {
            return this.explanation ? this.reason + ": " + this.explanation : this.reason;
        }, Invalid;
    }(), s = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
    function combineRegexes() {
        for (var _len = arguments.length, regexes = new Array(_len), _key = 0; _key < _len; _key++) regexes[_key] = arguments[_key];
        var full = regexes.reduce(function(f, r) {
            return f + r.source;
        }, "");
        return RegExp("^" + full + "$");
    }
    function combineExtractors() {
        for (var _len2 = arguments.length, extractors = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) extractors[_key2] = arguments[_key2];
        return function(m) {
            return extractors.reduce(function(_ref, ex) {
                var mergedVals = _ref[0], mergedZone = _ref[1], _ref = _ref[2], ex = ex(m, _ref), _ref = ex[0], zone = ex[1], ex = ex[2];
                return [ _extends({}, mergedVals, _ref), zone || mergedZone, ex ];
            }, [ {}, null, 1 ]).slice(0, 2);
        };
    }
    function parse(s) {
        if (null != s) {
            for (var _len3 = arguments.length, patterns = new Array(1 < _len3 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) patterns[_key3 - 1] = arguments[_key3];
            for (var _i = 0, _patterns = patterns; _i < _patterns.length; _i++) {
                var _patterns$_i = _patterns[_i], regex = _patterns$_i[0], _patterns$_i = _patterns$_i[1], regex = regex.exec(s);
                if (regex) return _patterns$_i(regex);
            }
        }
        return [ null, null ];
    }
    function simpleParse() {
        for (var _len4 = arguments.length, keys = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) keys[_key4] = arguments[_key4];
        return function(match, cursor) {
            for (var ret = {}, i = 0; i < keys.length; i++) ret[keys[i]] = parseInteger(match[cursor + i]);
            return [ ret, null, cursor + i ];
        };
    }
    var LuxonError = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/, l = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/, isoTimeRegex = RegExp(l.source + ("(?:" + LuxonError.source + "?(?:\\[(" + s.source + ")\\])?)?")), isoTimeExtensionRegex = RegExp("(?:T" + isoTimeRegex.source + ")?"), extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay"), extractISOOrdinalData = simpleParse("year", "ordinal"), LuxonError = RegExp(l.source + " ?(?:" + LuxonError.source + "|(" + s.source + "))?"), s = RegExp("(?: " + LuxonError.source + ")?");
    function int(match, pos, fallback) {
        match = match[pos];
        return void 0 === match ? fallback : parseInteger(match);
    }
    function extractISOTime(match, cursor) {
        return [ {
            hours: int(match, cursor, 0),
            minutes: int(match, cursor + 1, 0),
            seconds: int(match, cursor + 2, 0),
            milliseconds: parseMillis(match[cursor + 3])
        }, null, cursor + 4 ];
    }
    function extractISOOffset(match, cursor) {
        var local = !match[cursor] && !match[cursor + 1], match = signedOffset(match[cursor + 1], match[cursor + 2]);
        return [ {}, local ? null : FixedOffsetZone.instance(match), cursor + 3 ];
    }
    function extractIANAZone(match, cursor) {
        return [ {}, match[cursor] ? IANAZone.create(match[cursor]) : null, cursor + 1 ];
    }
    var isoTimeOnly = RegExp("^T?" + l.source + "$"), isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
    function extractISODuration(match) {
        function maybeNegate(num, force) {
            return void 0 === force && (force = !1), void 0 !== num && (force || num && hasNegativePrefix) ? -num : num;
        }
        var s = match[0], yearStr = match[1], monthStr = match[2], weekStr = match[3], dayStr = match[4], hourStr = match[5], minuteStr = match[6], secondStr = match[7], match = match[8], hasNegativePrefix = "-" === s[0], s = secondStr && "-" === secondStr[0];
        return [ {
            years: maybeNegate(parseFloating(yearStr)),
            months: maybeNegate(parseFloating(monthStr)),
            weeks: maybeNegate(parseFloating(weekStr)),
            days: maybeNegate(parseFloating(dayStr)),
            hours: maybeNegate(parseFloating(hourStr)),
            minutes: maybeNegate(parseFloating(minuteStr)),
            seconds: maybeNegate(parseFloating(secondStr), "-0" === secondStr),
            milliseconds: maybeNegate(parseMillis(match), s)
        } ];
    }
    var obsOffsets = {
        GMT: 0,
        EDT: -240,
        EST: -300,
        CDT: -300,
        CST: -360,
        MDT: -360,
        MST: -420,
        PDT: -420,
        PST: -480
    };
    function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        yearStr = {
            year: 2 === yearStr.length ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
            month: monthsShort.indexOf(monthStr) + 1,
            day: parseInteger(dayStr),
            hour: parseInteger(hourStr),
            minute: parseInteger(minuteStr)
        };
        return secondStr && (yearStr.second = parseInteger(secondStr)), weekdayStr && (yearStr.weekday = 3 < weekdayStr.length ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1), yearStr;
    }
    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
    function extractRFC2822(match) {
        var weekdayStr = match[1], dayStr = match[2], monthStr = match[3], yearStr = match[4], hourStr = match[5], minuteStr = match[6], secondStr = match[7], obsOffset = match[8], milOffset = match[9], offHourStr = match[10], match = match[11], weekdayStr = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr), yearStr = obsOffset ? obsOffsets[obsOffset] : milOffset ? 0 : signedOffset(offHourStr, match);
        return [ weekdayStr, new FixedOffsetZone(yearStr) ];
    }
    var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/, rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/, ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
    function extractRFC1123Or850(match) {
        var weekdayStr = match[1], dayStr = match[2], monthStr = match[3];
        return [ fromStrings(weekdayStr, match[4], monthStr, dayStr, match[5], match[6], match[7]), FixedOffsetZone.utcInstance ];
    }
    function extractASCII(match) {
        var weekdayStr = match[1], monthStr = match[2], dayStr = match[3], hourStr = match[4], minuteStr = match[5], secondStr = match[6];
        return [ fromStrings(weekdayStr, match[7], monthStr, dayStr, hourStr, minuteStr, secondStr), FixedOffsetZone.utcInstance ];
    }
    var isoYmdWithTimeExtensionRegex = combineRegexes(/([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/, isoTimeExtensionRegex), isoWeekWithTimeExtensionRegex = combineRegexes(/(\d{4})-?W(\d\d)(?:-?(\d))?/, isoTimeExtensionRegex), isoOrdinalWithTimeExtensionRegex = combineRegexes(/(\d{4})-?(\d{3})/, isoTimeExtensionRegex), isoTimeCombinedRegex = combineRegexes(isoTimeRegex), extractISOYmdTimeAndOffset = combineExtractors(function(match, cursor) {
        return [ {
            year: int(match, cursor),
            month: int(match, cursor + 1, 1),
            day: int(match, cursor + 2, 1)
        }, null, cursor + 3 ];
    }, extractISOTime, extractISOOffset, extractIANAZone), extractISOWeekTimeAndOffset = combineExtractors(extractISOWeekData, extractISOTime, extractISOOffset, extractIANAZone), extractISOOrdinalDateAndTime = combineExtractors(extractISOOrdinalData, extractISOTime, extractISOOffset, extractIANAZone), extractISOTimeAndOffset = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);
    var extractISOTimeOnly = combineExtractors(extractISOTime);
    var sqlYmdWithTimeExtensionRegex = combineRegexes(/(\d{4})-(\d\d)-(\d\d)/, s), sqlTimeCombinedRegex = combineRegexes(LuxonError), extractISOTimeOffsetAndIANAZone = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);
    var l = {
        weeks: {
            days: 7,
            hours: 168,
            minutes: 10080,
            seconds: 604800,
            milliseconds: 6048e5
        },
        days: {
            hours: 24,
            minutes: 1440,
            seconds: 86400,
            milliseconds: 864e5
        },
        hours: {
            minutes: 60,
            seconds: 3600,
            milliseconds: 36e5
        },
        minutes: {
            seconds: 60,
            milliseconds: 6e4
        },
        seconds: {
            milliseconds: 1e3
        }
    }, casualMatrix = _extends({
        years: {
            quarters: 4,
            months: 12,
            weeks: 52,
            days: 365,
            hours: 8760,
            minutes: 525600,
            seconds: 31536e3,
            milliseconds: 31536e6
        },
        quarters: {
            months: 3,
            weeks: 13,
            days: 91,
            hours: 2184,
            minutes: 131040,
            seconds: 7862400,
            milliseconds: 78624e5
        },
        months: {
            weeks: 4,
            days: 30,
            hours: 720,
            minutes: 43200,
            seconds: 2592e3,
            milliseconds: 2592e6
        }
    }, l), accurateMatrix = _extends({
        years: {
            quarters: 4,
            months: 12,
            weeks: 52.1775,
            days: 365.2425,
            hours: 8765.82,
            minutes: 525949.2,
            seconds: 525949.2 * 60,
            milliseconds: 525949.2 * 60 * 1e3
        },
        quarters: {
            months: 3,
            weeks: 13.044375,
            days: 91.310625,
            hours: 2191.455,
            minutes: 131487.3,
            seconds: 525949.2 * 60 / 4,
            milliseconds: 7889237999.999999
        },
        months: {
            weeks: 30.436875 / 7,
            days: 30.436875,
            hours: 730.485,
            minutes: 43829.1,
            seconds: 2629746,
            milliseconds: 2629746e3
        }
    }, l), orderedUnits$1 = [ "years", "quarters", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds" ], reverseUnits = orderedUnits$1.slice(0).reverse();
    function clone$1(dur, alts, clear) {
        clear = {
            values: (clear = void 0 === clear ? !1 : clear) ? alts.values : _extends({}, dur.values, alts.values || {}),
            loc: dur.loc.clone(alts.loc),
            conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
            matrix: alts.matrix || dur.matrix
        };
        return new Duration(clear);
    }
    function durationToMillis(matrix, vals) {
        for (var _vals$milliseconds, sum = null != (_vals$milliseconds = vals.milliseconds) ? _vals$milliseconds : 0, _iterator = _createForOfIteratorHelperLoose(reverseUnits.slice(1)); !(_step = _iterator()).done; ) {
            var _step = _step.value;
            vals[_step] && (sum += vals[_step] * matrix[_step].milliseconds);
        }
        return sum;
    }
    function normalizeValues(matrix, vals) {
        var factor = durationToMillis(matrix, vals) < 0 ? -1 : 1;
        orderedUnits$1.reduceRight(function(previous, current) {
            var conv, previousVal;
            return void 0 !== vals[current] ? (previous && (previousVal = vals[previous] * factor, conv = matrix[current][previous], previousVal = Math.floor(previousVal / conv), vals[current] += previousVal * factor, vals[previous] -= previousVal * conv * factor), current) : previous;
        }, null), orderedUnits$1.reduce(function(previous, current) {
            var fraction;
            return void 0 !== vals[current] ? (previous && (fraction = vals[previous] % 1, vals[previous] -= fraction, vals[current] += fraction * matrix[previous][current]), current) : previous;
        }, null);
    }
    var Duration = function() {
        function Duration(config) {
            var accurate = "longterm" === config.conversionAccuracy || !1, matrix = accurate ? accurateMatrix : casualMatrix;
            config.matrix && (matrix = config.matrix), this.values = config.values, this.loc = config.loc || Locale.create(), this.conversionAccuracy = accurate ? "longterm" : "casual", this.invalid = config.invalid || null, this.matrix = matrix, this.isLuxonDuration = !0;
        }
        Duration.fromMillis = function(count, opts) {
            return Duration.fromObject({
                milliseconds: count
            }, opts);
        }, Duration.fromObject = function(obj, opts) {
            if (void 0 === opts && (opts = {}), null == obj || "object" != typeof obj) throw new InvalidArgumentError("Duration.fromObject: argument expected to be an object, got " + (null === obj ? "null" : typeof obj));
            return new Duration({
                values: normalizeObject(obj, Duration.normalizeUnit),
                loc: Locale.fromObject(opts),
                conversionAccuracy: opts.conversionAccuracy,
                matrix: opts.matrix
            });
        }, Duration.fromDurationLike = function(durationLike) {
            if (isNumber(durationLike)) return Duration.fromMillis(durationLike);
            if (Duration.isDuration(durationLike)) return durationLike;
            if ("object" == typeof durationLike) return Duration.fromObject(durationLike);
            throw new InvalidArgumentError("Unknown duration argument " + durationLike + " of type " + typeof durationLike);
        }, Duration.fromISO = function(text, opts) {
            var parsed = parse(text, [ isoDuration, extractISODuration ])[0];
            return parsed ? Duration.fromObject(parsed, opts) : Duration.invalid("unparsable", 'the input "' + text + "\" can't be parsed as ISO 8601");
        }, Duration.fromISOTime = function(text, opts) {
            var parsed = parse(text, [ isoTimeOnly, extractISOTimeOnly ])[0];
            return parsed ? Duration.fromObject(parsed, opts) : Duration.invalid("unparsable", 'the input "' + text + "\" can't be parsed as ISO 8601");
        }, Duration.invalid = function(reason, explanation) {
            if (void 0 === explanation && (explanation = null), !reason) throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
            reason = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
            if (Settings.throwOnInvalid) throw new InvalidDurationError(reason);
            return new Duration({
                invalid: reason
            });
        }, Duration.normalizeUnit = function(unit) {
            var normalized = {
                year: "years",
                years: "years",
                quarter: "quarters",
                quarters: "quarters",
                month: "months",
                months: "months",
                week: "weeks",
                weeks: "weeks",
                day: "days",
                days: "days",
                hour: "hours",
                hours: "hours",
                minute: "minutes",
                minutes: "minutes",
                second: "seconds",
                seconds: "seconds",
                millisecond: "milliseconds",
                milliseconds: "milliseconds"
            }[unit && unit.toLowerCase()];
            if (normalized) return normalized;
            throw new InvalidUnitError(unit);
        }, Duration.isDuration = function(o) {
            return o && o.isLuxonDuration || !1;
        };
        var _proto = Duration.prototype;
        return _proto.toFormat = function(fmt, opts) {
            opts = _extends({}, opts = void 0 === opts ? {} : opts, {
                floor: !1 !== opts.round && !1 !== opts.floor
            });
            return this.isValid ? Formatter.create(this.loc, opts).formatDurationFromString(this, fmt) : "Invalid Duration";
        }, _proto.toHuman = function(opts) {
            var l, _this = this;
            return void 0 === opts && (opts = {}), this.isValid ? (l = orderedUnits$1.map(function(unit) {
                var val = _this.values[unit];
                return void 0 === val ? null : _this.loc.numberFormatter(_extends({
                    style: "unit",
                    unitDisplay: "long"
                }, opts, {
                    unit: unit.slice(0, -1)
                })).format(val);
            }).filter(function(n) {
                return n;
            }), this.loc.listFormatter(_extends({
                type: "conjunction",
                style: opts.listStyle || "narrow"
            }, opts)).format(l)) : "Invalid Duration";
        }, _proto.toObject = function() {
            return this.isValid ? _extends({}, this.values) : {};
        }, _proto.toISO = function() {
            var s;
            return this.isValid ? (s = "P", 0 !== this.years && (s += this.years + "Y"), 0 === this.months && 0 === this.quarters || (s += this.months + 3 * this.quarters + "M"), 0 !== this.weeks && (s += this.weeks + "W"), 0 !== this.days && (s += this.days + "D"), 0 === this.hours && 0 === this.minutes && 0 === this.seconds && 0 === this.milliseconds || (s += "T"), 0 !== this.hours && (s += this.hours + "H"), 0 !== this.minutes && (s += this.minutes + "M"), 0 === this.seconds && 0 === this.milliseconds || (s += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S"), "P" === s && (s += "T0S"), s) : null;
        }, _proto.toISOTime = function(opts) {
            var millis;
            return void 0 === opts && (opts = {}), !this.isValid || (millis = this.toMillis()) < 0 || 864e5 <= millis ? null : (opts = _extends({
                suppressMilliseconds: !1,
                suppressSeconds: !1,
                includePrefix: !1,
                format: "extended"
            }, opts, {
                includeOffset: !1
            }), DateTime.fromMillis(millis, {
                zone: "UTC"
            }).toISOTime(opts));
        }, _proto.toJSON = function() {
            return this.toISO();
        }, _proto.toString = function() {
            return this.toISO();
        }, _proto.toMillis = function() {
            return this.isValid ? durationToMillis(this.matrix, this.values) : NaN;
        }, _proto.valueOf = function() {
            return this.toMillis();
        }, _proto.plus = function(duration) {
            if (!this.isValid) return this;
            for (var dur = Duration.fromDurationLike(duration), result = {}, _i2 = 0, _orderedUnits = orderedUnits$1; _i2 < _orderedUnits.length; _i2++) {
                var k = _orderedUnits[_i2];
                (hasOwnProperty(dur.values, k) || hasOwnProperty(this.values, k)) && (result[k] = dur.get(k) + this.get(k));
            }
            return clone$1(this, {
                values: result
            }, !0);
        }, _proto.minus = function(duration) {
            return this.isValid ? (duration = Duration.fromDurationLike(duration), this.plus(duration.negate())) : this;
        }, _proto.mapUnits = function(fn) {
            if (!this.isValid) return this;
            for (var result = {}, _i3 = 0, _Object$keys = Object.keys(this.values); _i3 < _Object$keys.length; _i3++) {
                var k = _Object$keys[_i3];
                result[k] = asNumber(fn(this.values[k], k));
            }
            return clone$1(this, {
                values: result
            }, !0);
        }, _proto.get = function(unit) {
            return this[Duration.normalizeUnit(unit)];
        }, _proto.set = function(values) {
            return this.isValid ? clone$1(this, {
                values: _extends({}, this.values, normalizeObject(values, Duration.normalizeUnit))
            }) : this;
        }, _proto.reconfigure = function(_temp) {
            var _temp = void 0 === _temp ? {} : _temp, locale = _temp.locale, numberingSystem = _temp.numberingSystem, conversionAccuracy = _temp.conversionAccuracy, _temp = _temp.matrix, locale = this.loc.clone({
                locale: locale,
                numberingSystem: numberingSystem
            });
            return clone$1(this, {
                loc: locale,
                matrix: _temp,
                conversionAccuracy: conversionAccuracy
            });
        }, _proto.as = function(unit) {
            return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
        }, _proto.normalize = function() {
            var vals;
            return this.isValid ? (vals = this.toObject(), normalizeValues(this.matrix, vals), clone$1(this, {
                values: vals
            }, !0)) : this;
        }, _proto.rescale = function() {
            var vals;
            return this.isValid ? (vals = function(vals) {
                for (var newVals = {}, _i = 0, _Object$entries = Object.entries(vals); _i < _Object$entries.length; _i++) {
                    var _Object$entries$_i = _Object$entries[_i], key = _Object$entries$_i[0], _Object$entries$_i = _Object$entries$_i[1];
                    0 !== _Object$entries$_i && (newVals[key] = _Object$entries$_i);
                }
                return newVals;
            }(this.normalize().shiftToAll().toObject()), clone$1(this, {
                values: vals
            }, !0)) : this;
        }, _proto.shiftTo = function() {
            for (var _len = arguments.length, units = new Array(_len), _key = 0; _key < _len; _key++) units[_key] = arguments[_key];
            if (!this.isValid) return this;
            if (0 === units.length) return this;
            for (var key, units = units.map(function(u) {
                return Duration.normalizeUnit(u);
            }), built = {}, accumulated = {}, vals = this.toObject(), _i4 = 0, _orderedUnits2 = orderedUnits$1; _i4 < _orderedUnits2.length; _i4++) {
                var k = _orderedUnits2[_i4];
                if (0 <= units.indexOf(k)) {
                    var ak, lastUnit = k, own = 0;
                    for (ak in accumulated) own += this.matrix[ak][k] * accumulated[ak], accumulated[ak] = 0;
                    isNumber(vals[k]) && (own += vals[k]);
                    var i = Math.trunc(own);
                    accumulated[k] = (1e3 * own - 1e3 * (built[k] = i)) / 1e3;
                } else isNumber(vals[k]) && (accumulated[k] = vals[k]);
            }
            for (key in accumulated) 0 !== accumulated[key] && (built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key]);
            return normalizeValues(this.matrix, built), clone$1(this, {
                values: built
            }, !0);
        }, _proto.shiftToAll = function() {
            return this.isValid ? this.shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds") : this;
        }, _proto.negate = function() {
            if (!this.isValid) return this;
            for (var negated = {}, _i5 = 0, _Object$keys2 = Object.keys(this.values); _i5 < _Object$keys2.length; _i5++) {
                var k = _Object$keys2[_i5];
                negated[k] = 0 === this.values[k] ? 0 : -this.values[k];
            }
            return clone$1(this, {
                values: negated
            }, !0);
        }, _proto.equals = function(other) {
            if (!this.isValid || !other.isValid) return !1;
            if (!this.loc.equals(other.loc)) return !1;
            for (var v1, _i6 = 0, _orderedUnits3 = orderedUnits$1; _i6 < _orderedUnits3.length; _i6++) {
                var u = _orderedUnits3[_i6];
                if (v1 = this.values[u], u = other.values[u], !(void 0 === v1 || 0 === v1 ? void 0 === u || 0 === u : v1 === u)) return !1;
            }
            return !0;
        }, _createClass(Duration, [ {
            key: "locale",
            get: function() {
                return this.isValid ? this.loc.locale : null;
            }
        }, {
            key: "numberingSystem",
            get: function() {
                return this.isValid ? this.loc.numberingSystem : null;
            }
        }, {
            key: "years",
            get: function() {
                return this.isValid ? this.values.years || 0 : NaN;
            }
        }, {
            key: "quarters",
            get: function() {
                return this.isValid ? this.values.quarters || 0 : NaN;
            }
        }, {
            key: "months",
            get: function() {
                return this.isValid ? this.values.months || 0 : NaN;
            }
        }, {
            key: "weeks",
            get: function() {
                return this.isValid ? this.values.weeks || 0 : NaN;
            }
        }, {
            key: "days",
            get: function() {
                return this.isValid ? this.values.days || 0 : NaN;
            }
        }, {
            key: "hours",
            get: function() {
                return this.isValid ? this.values.hours || 0 : NaN;
            }
        }, {
            key: "minutes",
            get: function() {
                return this.isValid ? this.values.minutes || 0 : NaN;
            }
        }, {
            key: "seconds",
            get: function() {
                return this.isValid ? this.values.seconds || 0 : NaN;
            }
        }, {
            key: "milliseconds",
            get: function() {
                return this.isValid ? this.values.milliseconds || 0 : NaN;
            }
        }, {
            key: "isValid",
            get: function() {
                return null === this.invalid;
            }
        }, {
            key: "invalidReason",
            get: function() {
                return this.invalid ? this.invalid.reason : null;
            }
        }, {
            key: "invalidExplanation",
            get: function() {
                return this.invalid ? this.invalid.explanation : null;
            }
        } ]), Duration;
    }(), INVALID$1 = "Invalid Interval";
    function validateStartEnd(start, end) {
        return start && start.isValid ? end && end.isValid ? end < start ? Interval.invalid("end before start", "The end of an interval must be after its start, but you had start=" + start.toISO() + " and end=" + end.toISO()) : null : Interval.invalid("missing or invalid end") : Interval.invalid("missing or invalid start");
    }
    var Interval = function() {
        function Interval(config) {
            this.s = config.start, this.e = config.end, this.invalid = config.invalid || null, this.isLuxonInterval = !0;
        }
        Interval.invalid = function(reason, explanation) {
            if (void 0 === explanation && (explanation = null), !reason) throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
            reason = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
            if (Settings.throwOnInvalid) throw new InvalidIntervalError(reason);
            return new Interval({
                invalid: reason
            });
        }, Interval.fromDateTimes = function(start, end) {
            var start = friendlyDateTime(start), end = friendlyDateTime(end), validateError = validateStartEnd(start, end);
            return null == validateError ? new Interval({
                start: start,
                end: end
            }) : validateError;
        }, Interval.after = function(start, duration) {
            duration = Duration.fromDurationLike(duration), start = friendlyDateTime(start);
            return Interval.fromDateTimes(start, start.plus(duration));
        }, Interval.before = function(end, duration) {
            duration = Duration.fromDurationLike(duration), end = friendlyDateTime(end);
            return Interval.fromDateTimes(end.minus(duration), end);
        }, Interval.fromISO = function(text, opts) {
            var start, end, endIsValid, _split = (text || "").split("/", 2), s = _split[0], e = _split[1];
            if (s && e) {
                try {
                    startIsValid = (start = DateTime.fromISO(s, opts)).isValid;
                } catch (e) {
                    startIsValid = !1;
                }
                try {
                    endIsValid = (end = DateTime.fromISO(e, opts)).isValid;
                } catch (e) {
                    endIsValid = !1;
                }
                if (startIsValid && endIsValid) return Interval.fromDateTimes(start, end);
                if (startIsValid) {
                    _split = Duration.fromISO(e, opts);
                    if (_split.isValid) return Interval.after(start, _split);
                } else if (endIsValid) {
                    var startIsValid = Duration.fromISO(s, opts);
                    if (startIsValid.isValid) return Interval.before(end, startIsValid);
                }
            }
            return Interval.invalid("unparsable", 'the input "' + text + "\" can't be parsed as ISO 8601");
        }, Interval.isInterval = function(o) {
            return o && o.isLuxonInterval || !1;
        };
        var _proto = Interval.prototype;
        return _proto.length = function(unit) {
            return void 0 === unit && (unit = "milliseconds"), this.isValid ? this.toDuration.apply(this, [ unit ]).get(unit) : NaN;
        }, _proto.count = function(unit) {
            var start, end;
            return void 0 === unit && (unit = "milliseconds"), this.isValid ? (start = this.start.startOf(unit), end = this.end.startOf(unit), Math.floor(end.diff(start, unit).get(unit)) + (end.valueOf() !== this.end.valueOf())) : NaN;
        }, _proto.hasSame = function(unit) {
            return !!this.isValid && (this.isEmpty() || this.e.minus(1).hasSame(this.s, unit));
        }, _proto.isEmpty = function() {
            return this.s.valueOf() === this.e.valueOf();
        }, _proto.isAfter = function(dateTime) {
            return !!this.isValid && this.s > dateTime;
        }, _proto.isBefore = function(dateTime) {
            return !!this.isValid && this.e <= dateTime;
        }, _proto.contains = function(dateTime) {
            return !!this.isValid && this.s <= dateTime && this.e > dateTime;
        }, _proto.set = function(_temp) {
            var _temp = void 0 === _temp ? {} : _temp, start = _temp.start, _temp = _temp.end;
            return this.isValid ? Interval.fromDateTimes(start || this.s, _temp || this.e) : this;
        }, _proto.splitAt = function() {
            var _this = this;
            if (!this.isValid) return [];
            for (var _len = arguments.length, dateTimes = new Array(_len), _key = 0; _key < _len; _key++) dateTimes[_key] = arguments[_key];
            for (var sorted = dateTimes.map(friendlyDateTime).filter(function(d) {
                return _this.contains(d);
            }).sort(), results = [], s = this.s, i = 0; s < this.e; ) {
                var added = sorted[i] || this.e, added = +added > +this.e ? this.e : added;
                results.push(Interval.fromDateTimes(s, added)), s = added, i += 1;
            }
            return results;
        }, _proto.splitBy = function(duration) {
            var dur = Duration.fromDurationLike(duration);
            if (!this.isValid || !dur.isValid || 0 === dur.as("milliseconds")) return [];
            for (var s = this.s, idx = 1, results = []; s < this.e; ) {
                var added = this.start.plus(dur.mapUnits(function(x) {
                    return x * idx;
                })), added = +added > +this.e ? this.e : added;
                results.push(Interval.fromDateTimes(s, added)), s = added, idx += 1;
            }
            return results;
        }, _proto.divideEqually = function(numberOfParts) {
            return this.isValid ? this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts) : [];
        }, _proto.overlaps = function(other) {
            return this.e > other.s && this.s < other.e;
        }, _proto.abutsStart = function(other) {
            return !!this.isValid && +this.e == +other.s;
        }, _proto.abutsEnd = function(other) {
            return !!this.isValid && +other.e == +this.s;
        }, _proto.engulfs = function(other) {
            return !!this.isValid && this.s <= other.s && this.e >= other.e;
        }, _proto.equals = function(other) {
            return !(!this.isValid || !other.isValid) && this.s.equals(other.s) && this.e.equals(other.e);
        }, _proto.intersection = function(other) {
            var s;
            return this.isValid ? (s = (this.s > other.s ? this : other).s, (other = (this.e < other.e ? this : other).e) <= s ? null : Interval.fromDateTimes(s, other)) : this;
        }, _proto.union = function(other) {
            var s;
            return this.isValid ? (s = (this.s < other.s ? this : other).s, other = (this.e > other.e ? this : other).e, Interval.fromDateTimes(s, other)) : this;
        }, Interval.merge = function(intervals) {
            var intervals = intervals.sort(function(a, b) {
                return a.s - b.s;
            }).reduce(function(_ref2, item) {
                var sofar = _ref2[0], _ref2 = _ref2[1];
                return _ref2 ? _ref2.overlaps(item) || _ref2.abutsStart(item) ? [ sofar, _ref2.union(item) ] : [ sofar.concat([ _ref2 ]), item ] : [ sofar, item ];
            }, [ [], null ]), found = intervals[0], intervals = intervals[1];
            return intervals && found.push(intervals), found;
        }, Interval.xor = function(intervals) {
            for (var _Array$prototype, start = null, currentCount = 0, results = [], intervals = intervals.map(function(i) {
                return [ {
                    time: i.s,
                    type: "s"
                }, {
                    time: i.e,
                    type: "e"
                } ];
            }), _iterator = _createForOfIteratorHelperLoose((_Array$prototype = Array.prototype).concat.apply(_Array$prototype, intervals).sort(function(a, b) {
                return a.time - b.time;
            })); !(_step = _iterator()).done; ) var _step = _step.value, start = 1 === (currentCount += "s" === _step.type ? 1 : -1) ? _step.time : (start && +start != +_step.time && results.push(Interval.fromDateTimes(start, _step.time)), null);
            return Interval.merge(results);
        }, _proto.difference = function() {
            for (var _this2 = this, _len2 = arguments.length, intervals = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) intervals[_key2] = arguments[_key2];
            return Interval.xor([ this ].concat(intervals)).map(function(i) {
                return _this2.intersection(i);
            }).filter(function(i) {
                return i && !i.isEmpty();
            });
        }, _proto.toString = function() {
            return this.isValid ? "[" + this.s.toISO() + " – " + this.e.toISO() + ")" : INVALID$1;
        }, _proto.toLocaleString = function(formatOpts, opts) {
            return void 0 === formatOpts && (formatOpts = DATE_SHORT), void 0 === opts && (opts = {}), this.isValid ? Formatter.create(this.s.loc.clone(opts), formatOpts).formatInterval(this) : INVALID$1;
        }, _proto.toISO = function(opts) {
            return this.isValid ? this.s.toISO(opts) + "/" + this.e.toISO(opts) : INVALID$1;
        }, _proto.toISODate = function() {
            return this.isValid ? this.s.toISODate() + "/" + this.e.toISODate() : INVALID$1;
        }, _proto.toISOTime = function(opts) {
            return this.isValid ? this.s.toISOTime(opts) + "/" + this.e.toISOTime(opts) : INVALID$1;
        }, _proto.toFormat = function(dateFormat, _temp2) {
            _temp2 = (void 0 === _temp2 ? {} : _temp2).separator, _temp2 = void 0 === _temp2 ? " – " : _temp2;
            return this.isValid ? "" + this.s.toFormat(dateFormat) + _temp2 + this.e.toFormat(dateFormat) : INVALID$1;
        }, _proto.toDuration = function(unit, opts) {
            return this.isValid ? this.e.diff(this.s, unit, opts) : Duration.invalid(this.invalidReason);
        }, _proto.mapEndpoints = function(mapFn) {
            return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
        }, _createClass(Interval, [ {
            key: "start",
            get: function() {
                return this.isValid ? this.s : null;
            }
        }, {
            key: "end",
            get: function() {
                return this.isValid ? this.e : null;
            }
        }, {
            key: "isValid",
            get: function() {
                return null === this.invalidReason;
            }
        }, {
            key: "invalidReason",
            get: function() {
                return this.invalid ? this.invalid.reason : null;
            }
        }, {
            key: "invalidExplanation",
            get: function() {
                return this.invalid ? this.invalid.explanation : null;
            }
        } ]), Interval;
    }(), Info = function() {
        function Info() {}
        return Info.hasDST = function(zone) {
            void 0 === zone && (zone = Settings.defaultZone);
            var proto = DateTime.now().setZone(zone).set({
                month: 12
            });
            return !zone.isUniversal && proto.offset !== proto.set({
                month: 6
            }).offset;
        }, Info.isValidIANAZone = function(zone) {
            return IANAZone.isValidZone(zone);
        }, Info.normalizeZone = function(input) {
            return normalizeZone(input, Settings.defaultZone);
        }, Info.months = function(length, _temp) {
            void 0 === length && (length = "long");
            var _temp = void 0 === _temp ? {} : _temp, _ref$locale = _temp.locale, _ref$numberingSystem = _temp.numberingSystem, _ref$locObj = _temp.locObj, _ref$locObj = void 0 === _ref$locObj ? null : _ref$locObj, _temp = _temp.outputCalendar;
            return (_ref$locObj || Locale.create(void 0 === _ref$locale ? null : _ref$locale, void 0 === _ref$numberingSystem ? null : _ref$numberingSystem, void 0 === _temp ? "gregory" : _temp)).months(length);
        }, Info.monthsFormat = function(length, _temp2) {
            void 0 === length && (length = "long");
            var _temp2 = void 0 === _temp2 ? {} : _temp2, _ref2$locale = _temp2.locale, _ref2$numberingSystem = _temp2.numberingSystem, _ref2$locObj = _temp2.locObj, _ref2$locObj = void 0 === _ref2$locObj ? null : _ref2$locObj, _temp2 = _temp2.outputCalendar;
            return (_ref2$locObj || Locale.create(void 0 === _ref2$locale ? null : _ref2$locale, void 0 === _ref2$numberingSystem ? null : _ref2$numberingSystem, void 0 === _temp2 ? "gregory" : _temp2)).months(length, !0);
        }, Info.weekdays = function(length, _temp3) {
            void 0 === length && (length = "long");
            var _temp3 = void 0 === _temp3 ? {} : _temp3, _ref3$locale = _temp3.locale, _ref3$numberingSystem = _temp3.numberingSystem, _temp3 = _temp3.locObj;
            return ((void 0 === _temp3 ? null : _temp3) || Locale.create(void 0 === _ref3$locale ? null : _ref3$locale, void 0 === _ref3$numberingSystem ? null : _ref3$numberingSystem, null)).weekdays(length);
        }, Info.weekdaysFormat = function(length, _temp4) {
            void 0 === length && (length = "long");
            var _temp4 = void 0 === _temp4 ? {} : _temp4, _ref4$locale = _temp4.locale, _ref4$numberingSystem = _temp4.numberingSystem, _temp4 = _temp4.locObj;
            return ((void 0 === _temp4 ? null : _temp4) || Locale.create(void 0 === _ref4$locale ? null : _ref4$locale, void 0 === _ref4$numberingSystem ? null : _ref4$numberingSystem, null)).weekdays(length, !0);
        }, Info.meridiems = function(_temp5) {
            _temp5 = (void 0 === _temp5 ? {} : _temp5).locale;
            return Locale.create(void 0 === _temp5 ? null : _temp5).meridiems();
        }, Info.eras = function(length, _temp6) {
            void 0 === length && (length = "short");
            _temp6 = (void 0 === _temp6 ? {} : _temp6).locale;
            return Locale.create(void 0 === _temp6 ? null : _temp6, null, "gregory").eras(length);
        }, Info.features = function() {
            return {
                relative: hasRelative()
            };
        }, Info;
    }();
    function dayDiff(earlier, later) {
        function utcDayStart(dt) {
            return dt.toUTC(0, {
                keepLocalTime: !0
            }).startOf("day").valueOf();
        }
        later = utcDayStart(later) - utcDayStart(earlier);
        return Math.floor(Duration.fromMillis(later).as("days"));
    }
    function _diff(earlier, later, units, opts) {
        var earlier = function(cursor, later, units) {
            for (var lowestOrder, highWater, results = {}, earlier = cursor, _i = 0, _differs = [ [ "years", function(a, b) {
                return b.year - a.year;
            } ], [ "quarters", function(a, b) {
                return b.quarter - a.quarter + 4 * (b.year - a.year);
            } ], [ "months", function(a, b) {
                return b.month - a.month + 12 * (b.year - a.year);
            } ], [ "weeks", function(a, b) {
                a = dayDiff(a, b);
                return (a - a % 7) / 7;
            } ], [ "days", dayDiff ] ]; _i < _differs.length; _i++) {
                var _differs$_i = _differs[_i], unit = _differs$_i[0], _differs$_i = _differs$_i[1];
                0 <= units.indexOf(unit) && (results[lowestOrder = unit] = _differs$_i(cursor, later), later < (highWater = earlier.plus(results)) ? (results[unit]--, later < (cursor = earlier.plus(results)) && (highWater = cursor, results[unit]--, cursor = earlier.plus(results))) : cursor = highWater);
            }
            return [ cursor, results, highWater, lowestOrder ];
        }(earlier, later, units), cursor = earlier[0], results = earlier[1], highWater = earlier[2], earlier = earlier[3], remainingMillis = later - cursor, units = units.filter(function(u) {
            return 0 <= [ "hours", "minutes", "seconds", "milliseconds" ].indexOf(u);
        }), later = (0 === units.length && (highWater = highWater < later ? cursor.plus(((later = {})[earlier] = 1, later)) : highWater) !== cursor && (results[earlier] = (results[earlier] || 0) + remainingMillis / (highWater - cursor)), Duration.fromObject(results, opts));
        return 0 < units.length ? (earlier = Duration.fromMillis(remainingMillis, opts)).shiftTo.apply(earlier, units).plus(later) : later;
    }
    var numberingSystems = {
        arab: "[٠-٩]",
        arabext: "[۰-۹]",
        bali: "[᭐-᭙]",
        beng: "[০-৯]",
        deva: "[०-९]",
        fullwide: "[０-９]",
        gujr: "[૦-૯]",
        hanidec: "[〇|一|二|三|四|五|六|七|八|九]",
        khmr: "[០-៩]",
        knda: "[೦-೯]",
        laoo: "[໐-໙]",
        limb: "[᥆-᥏]",
        mlym: "[൦-൯]",
        mong: "[᠐-᠙]",
        mymr: "[၀-၉]",
        orya: "[୦-୯]",
        tamldec: "[௦-௯]",
        telu: "[౦-౯]",
        thai: "[๐-๙]",
        tibt: "[༠-༩]",
        latn: "\\d"
    }, numberingSystemsUTF16 = {
        arab: [ 1632, 1641 ],
        arabext: [ 1776, 1785 ],
        bali: [ 6992, 7001 ],
        beng: [ 2534, 2543 ],
        deva: [ 2406, 2415 ],
        fullwide: [ 65296, 65303 ],
        gujr: [ 2790, 2799 ],
        khmr: [ 6112, 6121 ],
        knda: [ 3302, 3311 ],
        laoo: [ 3792, 3801 ],
        limb: [ 6470, 6479 ],
        mlym: [ 3430, 3439 ],
        mong: [ 6160, 6169 ],
        mymr: [ 4160, 4169 ],
        orya: [ 2918, 2927 ],
        tamldec: [ 3046, 3055 ],
        telu: [ 3174, 3183 ],
        thai: [ 3664, 3673 ],
        tibt: [ 3872, 3881 ]
    }, hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
    function digitRegex(_ref, append) {
        _ref = _ref.numberingSystem;
        return void 0 === append && (append = ""), new RegExp("" + numberingSystems[_ref || "latn"] + append);
    }
    var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
    function intUnit(regex, post) {
        return void 0 === post && (post = function(i) {
            return i;
        }), {
            regex: regex,
            deser: function(_ref) {
                _ref = _ref[0];
                return post(function(str) {
                    var value = parseInt(str, 10);
                    if (isNaN(value)) {
                        for (var value = "", i = 0; i < str.length; i++) {
                            var code = str.charCodeAt(i);
                            if (-1 !== str[i].search(numberingSystems.hanidec)) value += hanidecChars.indexOf(str[i]); else for (var key in numberingSystemsUTF16) {
                                var key = numberingSystemsUTF16[key], min = key[0], key = key[1];
                                min <= code && code <= key && (value += code - min);
                            }
                        }
                        return parseInt(value, 10);
                    }
                    return value;
                }(_ref));
            }
        };
    }
    var spaceOrNBSP = "[ " + String.fromCharCode(160) + "]", spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
    function fixListRegex(s) {
        return s.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
    }
    function stripInsensitivities(s) {
        return s.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
    }
    function oneOf(strings, startIndex) {
        return null === strings ? null : {
            regex: RegExp(strings.map(fixListRegex).join("|")),
            deser: function(_ref2) {
                var s = _ref2[0];
                return strings.findIndex(function(i) {
                    return stripInsensitivities(s) === stripInsensitivities(i);
                }) + startIndex;
            }
        };
    }
    function offset(regex, groups) {
        return {
            regex: regex,
            deser: function(_ref3) {
                return signedOffset(_ref3[1], _ref3[2]);
            },
            groups: groups
        };
    }
    function simple(regex) {
        return {
            regex: regex,
            deser: function(_ref4) {
                return _ref4[0];
            }
        };
    }
    function unitForToken(token, loc) {
        function literal(t) {
            return {
                regex: RegExp(t.val.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&")),
                deser: function(_ref5) {
                    return _ref5[0];
                },
                literal: !0
            };
        }
        var one = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), unit = function(t) {
            if (token.literal) return literal(t);
            switch (t.val) {
              case "G":
                return oneOf(loc.eras("short"), 0);

              case "GG":
                return oneOf(loc.eras("long"), 0);

              case "y":
                return intUnit(oneToSix);

              case "yy":
                return intUnit(twoToFour, untruncateYear);

              case "yyyy":
                return intUnit(four);

              case "yyyyy":
                return intUnit(fourToSix);

              case "yyyyyy":
                return intUnit(six);

              case "M":
                return intUnit(oneOrTwo);

              case "MM":
                return intUnit(two);

              case "MMM":
                return oneOf(loc.months("short", !0), 1);

              case "MMMM":
                return oneOf(loc.months("long", !0), 1);

              case "L":
                return intUnit(oneOrTwo);

              case "LL":
                return intUnit(two);

              case "LLL":
                return oneOf(loc.months("short", !1), 1);

              case "LLLL":
                return oneOf(loc.months("long", !1), 1);

              case "d":
                return intUnit(oneOrTwo);

              case "dd":
                return intUnit(two);

              case "o":
                return intUnit(oneToThree);

              case "ooo":
                return intUnit(three);

              case "HH":
                return intUnit(two);

              case "H":
                return intUnit(oneOrTwo);

              case "hh":
                return intUnit(two);

              case "h":
                return intUnit(oneOrTwo);

              case "mm":
                return intUnit(two);

              case "m":
              case "q":
                return intUnit(oneOrTwo);

              case "qq":
                return intUnit(two);

              case "s":
                return intUnit(oneOrTwo);

              case "ss":
                return intUnit(two);

              case "S":
                return intUnit(oneToThree);

              case "SSS":
                return intUnit(three);

              case "u":
                return simple(oneToNine);

              case "uu":
                return simple(oneOrTwo);

              case "uuu":
                return intUnit(one);

              case "a":
                return oneOf(loc.meridiems(), 0);

              case "kkkk":
                return intUnit(four);

              case "kk":
                return intUnit(twoToFour, untruncateYear);

              case "W":
                return intUnit(oneOrTwo);

              case "WW":
                return intUnit(two);

              case "E":
              case "c":
                return intUnit(one);

              case "EEE":
                return oneOf(loc.weekdays("short", !1), 1);

              case "EEEE":
                return oneOf(loc.weekdays("long", !1), 1);

              case "ccc":
                return oneOf(loc.weekdays("short", !0), 1);

              case "cccc":
                return oneOf(loc.weekdays("long", !0), 1);

              case "Z":
              case "ZZ":
                return offset(new RegExp("([+-]" + oneOrTwo.source + ")(?::(" + two.source + "))?"), 2);

              case "ZZZ":
                return offset(new RegExp("([+-]" + oneOrTwo.source + ")(" + two.source + ")?"), 2);

              case "z":
                return simple(/[a-z_+-/]{1,256}?/i);

              case " ":
                return simple(/[^\S\n\r]/);

              default:
                return literal(t);
            }
        }(token) || {
            invalidReason: MISSING_FTP
        };
        return unit.token = token, unit;
    }
    var partTypeStyleToTokenVal = {
        year: {
            "2-digit": "yy",
            numeric: "yyyyy"
        },
        month: {
            numeric: "M",
            "2-digit": "MM",
            short: "MMM",
            long: "MMMM"
        },
        day: {
            numeric: "d",
            "2-digit": "dd"
        },
        weekday: {
            short: "EEE",
            long: "EEEE"
        },
        dayperiod: "a",
        dayPeriod: "a",
        hour12: {
            numeric: "h",
            "2-digit": "hh"
        },
        hour24: {
            numeric: "H",
            "2-digit": "HH"
        },
        minute: {
            numeric: "m",
            "2-digit": "mm"
        },
        second: {
            numeric: "s",
            "2-digit": "ss"
        },
        timeZoneName: {
            long: "ZZZZZ",
            short: "ZZZ"
        }
    };
    var dummyDateTimeCache = null;
    function expandMacroTokens(tokens, locale) {
        var _Array$prototype;
        return (_Array$prototype = Array.prototype).concat.apply(_Array$prototype, tokens.map(function(t) {
            return function(token, locale) {
                return token.literal || null == (locale = formatOptsToTokens(Formatter.macroTokenToFormatOpts(token.val), locale)) || locale.includes(void 0) ? token : locale;
            }(t, locale);
        }));
    }
    function explainFromTokens(locale, input, format) {
        var format = expandMacroTokens(Formatter.parseFormat(format), locale), units = format.map(function(t) {
            return unitForToken(t, locale);
        }), disqualifyingUnit = units.find(function(t) {
            return t.invalidReason;
        });
        if (disqualifyingUnit) return {
            input: input,
            tokens: format,
            invalidReason: disqualifyingUnit.invalidReason
        };
        var disqualifyingUnit = function(units) {
            return [ "^" + units.map(function(u) {
                return u.regex;
            }).reduce(function(f, r) {
                return f + "(" + r.source + ")";
            }, "") + "$", units ];
        }(units), units = disqualifyingUnit[0], disqualifyingUnit = disqualifyingUnit[1], units = RegExp(units, "i"), disqualifyingUnit = function(input, regex, handlers) {
            var matches = input.match(regex);
            if (matches) {
                var i, h, groups, all = {}, matchIndex = 1;
                for (i in handlers) hasOwnProperty(handlers, i) && (groups = (h = handlers[i]).groups ? h.groups + 1 : 1, !h.literal && h.token && (all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups))), matchIndex += groups);
                return [ matches, all ];
            }
            return [ matches, {} ];
        }(input, units, disqualifyingUnit), rawMatches = disqualifyingUnit[0], disqualifyingUnit = disqualifyingUnit[1], _ref6 = disqualifyingUnit ? function(matches) {
            var specificOffset, zone = null;
            return void 0 !== matches.z && (zone = IANAZone.create(matches.z)), void 0 !== matches.Z && (zone = zone || new FixedOffsetZone(matches.Z), specificOffset = matches.Z), void 0 !== matches.q && (matches.M = 3 * (matches.q - 1) + 1), void 0 !== matches.h && (matches.h < 12 && 1 === matches.a ? matches.h += 12 : 12 === matches.h && 0 === matches.a && (matches.h = 0)), 0 === matches.G && matches.y && (matches.y = -matches.y), void 0 !== matches.u && (matches.S = parseMillis(matches.u)), [ Object.keys(matches).reduce(function(r, k) {
                var f = function(token) {
                    switch (token) {
                      case "S":
                        return "millisecond";

                      case "s":
                        return "second";

                      case "m":
                        return "minute";

                      case "h":
                      case "H":
                        return "hour";

                      case "d":
                        return "day";

                      case "o":
                        return "ordinal";

                      case "L":
                      case "M":
                        return "month";

                      case "y":
                        return "year";

                      case "E":
                      case "c":
                        return "weekday";

                      case "W":
                        return "weekNumber";

                      case "k":
                        return "weekYear";

                      case "q":
                        return "quarter";

                      default:
                        return null;
                    }
                }(k);
                return f && (r[f] = matches[k]), r;
            }, {}), zone, specificOffset ];
        }(disqualifyingUnit) : [ null, null, void 0 ], result = _ref6[0], zone = _ref6[1], _ref6 = _ref6[2];
        if (hasOwnProperty(disqualifyingUnit, "a") && hasOwnProperty(disqualifyingUnit, "H")) throw new ConflictingSpecificationError("Can't include meridiem when specifying 24-hour format");
        return {
            input: input,
            tokens: format,
            regex: units,
            rawMatches: rawMatches,
            matches: disqualifyingUnit,
            result: result,
            zone: zone,
            specificOffset: _ref6
        };
    }
    function formatOptsToTokens(formatOpts, locale) {
        var parts, resolvedOpts;
        return formatOpts ? (parts = (locale = Formatter.create(locale, formatOpts).dtFormatter(dummyDateTimeCache = dummyDateTimeCache || DateTime.fromMillis(1555555555555))).formatToParts(), resolvedOpts = locale.resolvedOptions(), parts.map(function(p) {
            return function(part, formatOpts, resolvedOpts) {
                var isSpace, type = part.type, part = part.value;
                return "literal" === type ? {
                    literal: !(isSpace = /^\s+$/.test(part)),
                    val: isSpace ? " " : part
                } : (isSpace = formatOpts[type], "hour" === (part = type) && (part = null != formatOpts.hour12 ? formatOpts.hour12 ? "hour12" : "hour24" : null != formatOpts.hourCycle ? "h11" === formatOpts.hourCycle || "h12" === formatOpts.hourCycle ? "hour12" : "hour24" : resolvedOpts.hour12 ? "hour12" : "hour24"), (type = "object" == typeof (type = partTypeStyleToTokenVal[part]) ? type[isSpace] : type) ? {
                    literal: !1,
                    val: type
                } : void 0);
            }(p, formatOpts, resolvedOpts);
        })) : null;
    }
    var nonLeapLadder = [ 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 ], leapLadder = [ 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335 ];
    function unitOutOfRange(unit, value) {
        return new Invalid("unit out of range", "you specified " + value + " (of type " + typeof value + ") as a " + unit + ", which is invalid");
    }
    function dayOfWeek(year, month, day) {
        month = new Date(Date.UTC(year, month - 1, day)), year < 100 && 0 <= year && month.setUTCFullYear(month.getUTCFullYear() - 1900), day = month.getUTCDay();
        return 0 === day ? 7 : day;
    }
    function computeOrdinal(year, month, day) {
        return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
    }
    function uncomputeOrdinal(year, ordinal) {
        var year = isLeapYear(year) ? leapLadder : nonLeapLadder, month0 = year.findIndex(function(i) {
            return i < ordinal;
        });
        return {
            month: month0 + 1,
            day: ordinal - year[month0]
        };
    }
    function gregorianToWeek(gregObj) {
        var weekYear, year = gregObj.year, month = gregObj.month, day = gregObj.day, ordinal = computeOrdinal(year, month, day), month = dayOfWeek(year, month, day), day = Math.floor((ordinal - month + 10) / 7);
        return day < 1 ? day = weeksInWeekYear(weekYear = year - 1) : day > weeksInWeekYear(year) ? (weekYear = year + 1, day = 1) : weekYear = year, _extends({
            weekYear: weekYear,
            weekNumber: day,
            weekday: month
        }, timeObject(gregObj));
    }
    function weekToGregorian(weekData) {
        var year, weekYear = weekData.weekYear, weekNumber = weekData.weekNumber, weekday = weekData.weekday, weekdayOfJan4 = dayOfWeek(weekYear, 1, 4), yearInDays = daysInYear(weekYear), weekNumber = 7 * weekNumber + weekday - weekdayOfJan4 - 3, weekday = (weekNumber < 1 ? weekNumber += daysInYear(year = weekYear - 1) : yearInDays < weekNumber ? (year = weekYear + 1, weekNumber -= daysInYear(weekYear)) : year = weekYear, uncomputeOrdinal(year, weekNumber));
        return _extends({
            year: year,
            month: weekday.month,
            day: weekday.day
        }, timeObject(weekData));
    }
    function gregorianToOrdinal(gregData) {
        var year = gregData.year;
        return _extends({
            year: year,
            ordinal: computeOrdinal(year, gregData.month, gregData.day)
        }, timeObject(gregData));
    }
    function ordinalToGregorian(ordinalData) {
        var year = ordinalData.year, _uncomputeOrdinal2 = uncomputeOrdinal(year, ordinalData.ordinal);
        return _extends({
            year: year,
            month: _uncomputeOrdinal2.month,
            day: _uncomputeOrdinal2.day
        }, timeObject(ordinalData));
    }
    function hasInvalidGregorianData(obj) {
        var validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
        return validYear ? validMonth ? !validDay && unitOutOfRange("day", obj.day) : unitOutOfRange("month", obj.month) : unitOutOfRange("year", obj.year);
    }
    function hasInvalidTimeData(obj) {
        var hour = obj.hour, minute = obj.minute, second = obj.second, obj = obj.millisecond, validHour = integerBetween(hour, 0, 23) || 24 === hour && 0 === minute && 0 === second && 0 === obj, validMinute = integerBetween(minute, 0, 59), validSecond = integerBetween(second, 0, 59), validMillisecond = integerBetween(obj, 0, 999);
        return validHour ? validMinute ? validSecond ? !validMillisecond && unitOutOfRange("millisecond", obj) : unitOutOfRange("second", second) : unitOutOfRange("minute", minute) : unitOutOfRange("hour", hour);
    }
    var INVALID = "Invalid DateTime";
    function unsupportedZone(zone) {
        return new Invalid("unsupported zone", 'the zone "' + zone.name + '" is not supported');
    }
    function possiblyCachedWeekData(dt) {
        return null === dt.weekData && (dt.weekData = gregorianToWeek(dt.c)), dt.weekData;
    }
    function clone(inst, alts) {
        inst = {
            ts: inst.ts,
            zone: inst.zone,
            c: inst.c,
            o: inst.o,
            loc: inst.loc,
            invalid: inst.invalid
        };
        return new DateTime(_extends({}, inst, alts, {
            old: inst
        }));
    }
    function fixOffset(localTS, o, tz) {
        var utcGuess = localTS - 60 * o * 1e3, o2 = tz.offset(utcGuess);
        return o === o2 ? [ utcGuess, o ] : o2 === (tz = tz.offset(utcGuess -= 60 * (o2 - o) * 1e3)) ? [ utcGuess, o2 ] : [ localTS - 60 * Math.min(o2, tz) * 1e3, Math.max(o2, tz) ];
    }
    function tsToObj(ts, offset) {
        ts += 60 * offset * 1e3;
        offset = new Date(ts);
        return {
            year: offset.getUTCFullYear(),
            month: offset.getUTCMonth() + 1,
            day: offset.getUTCDate(),
            hour: offset.getUTCHours(),
            minute: offset.getUTCMinutes(),
            second: offset.getUTCSeconds(),
            millisecond: offset.getUTCMilliseconds()
        };
    }
    function objToTS(obj, offset, zone) {
        return fixOffset(objToLocalTS(obj), offset, zone);
    }
    function adjustTime(inst, dur) {
        var oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + 3 * Math.trunc(dur.quarters), year = _extends({}, inst.c, {
            year: year,
            month: month,
            day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + 7 * Math.trunc(dur.weeks)
        }), month = Duration.fromObject({
            years: dur.years - Math.trunc(dur.years),
            quarters: dur.quarters - Math.trunc(dur.quarters),
            months: dur.months - Math.trunc(dur.months),
            weeks: dur.weeks - Math.trunc(dur.weeks),
            days: dur.days - Math.trunc(dur.days),
            hours: dur.hours,
            minutes: dur.minutes,
            seconds: dur.seconds,
            milliseconds: dur.milliseconds
        }).as("milliseconds"), dur = fixOffset(objToLocalTS(year), oPre, inst.zone), year = dur[0], oPre = dur[1];
        return 0 !== month && (oPre = inst.zone.offset(year += month)), {
            ts: year,
            o: oPre
        };
    }
    function parseDataToDateTime(parsed, parsedZone, opts, format, text, specificOffset) {
        var setZone = opts.setZone, zone = opts.zone;
        return parsed && 0 !== Object.keys(parsed).length || parsedZone ? (parsed = DateTime.fromObject(parsed, _extends({}, opts, {
            zone: parsedZone || zone,
            specificOffset: specificOffset
        })), setZone ? parsed : parsed.setZone(zone)) : DateTime.invalid(new Invalid("unparsable", 'the input "' + text + "\" can't be parsed as " + format));
    }
    function toTechFormat(dt, format, allowZ) {
        return void 0 === allowZ && (allowZ = !0), dt.isValid ? Formatter.create(Locale.create("en-US"), {
            allowZ: allowZ,
            forceSimple: !0
        }).formatDateTimeFromString(dt, format) : null;
    }
    function _toISODate(o, extended) {
        var longFormat = 9999 < o.c.year || o.c.year < 0, c = "";
        return longFormat && 0 <= o.c.year && (c += "+"), c += padStart(o.c.year, longFormat ? 6 : 4), c = extended ? (c = (c += "-") + padStart(o.c.month) + "-") + padStart(o.c.day) : (c += padStart(o.c.month)) + padStart(o.c.day);
    }
    function _toISOTime(o, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone) {
        var c = padStart(o.c.hour);
        return extended ? (c = (c += ":") + padStart(o.c.minute), 0 === o.c.millisecond && 0 === o.c.second && suppressSeconds || (c += ":")) : c += padStart(o.c.minute), 0 === o.c.millisecond && 0 === o.c.second && suppressSeconds || (c += padStart(o.c.second), 0 === o.c.millisecond && suppressMilliseconds) || (c = (c += ".") + padStart(o.c.millisecond, 3)), includeOffset && (o.isOffsetFixed && 0 === o.offset && !extendedZone ? c += "Z" : c = o.o < 0 ? (c = (c += "-") + padStart(Math.trunc(-o.o / 60)) + ":") + padStart(Math.trunc(-o.o % 60)) : (c = (c += "+") + padStart(Math.trunc(o.o / 60)) + ":") + padStart(Math.trunc(o.o % 60))), extendedZone && (c += "[" + o.zone.ianaName + "]"), c;
    }
    var defaultUnitValues = {
        month: 1,
        day: 1,
        hour: 0,
        minute: 0,
        second: 0,
        millisecond: 0
    }, defaultWeekUnitValues = {
        weekNumber: 1,
        weekday: 1,
        hour: 0,
        minute: 0,
        second: 0,
        millisecond: 0
    }, defaultOrdinalUnitValues = {
        ordinal: 1,
        hour: 0,
        minute: 0,
        second: 0,
        millisecond: 0
    }, orderedUnits = [ "year", "month", "day", "hour", "minute", "second", "millisecond" ], orderedWeekUnits = [ "weekYear", "weekNumber", "weekday", "hour", "minute", "second", "millisecond" ], orderedOrdinalUnits = [ "year", "ordinal", "hour", "minute", "second", "millisecond" ];
    function normalizeUnit(unit) {
        var normalized = {
            year: "year",
            years: "year",
            month: "month",
            months: "month",
            day: "day",
            days: "day",
            hour: "hour",
            hours: "hour",
            minute: "minute",
            minutes: "minute",
            quarter: "quarter",
            quarters: "quarter",
            second: "second",
            seconds: "second",
            millisecond: "millisecond",
            milliseconds: "millisecond",
            weekday: "weekday",
            weekdays: "weekday",
            weeknumber: "weekNumber",
            weeksnumber: "weekNumber",
            weeknumbers: "weekNumber",
            weekyear: "weekYear",
            weekyears: "weekYear",
            ordinal: "ordinal"
        }[unit.toLowerCase()];
        if (normalized) return normalized;
        throw new InvalidUnitError(unit);
    }
    function quickDT(obj, opts) {
        var zone = normalizeZone(opts.zone, Settings.defaultZone), opts = Locale.fromObject(opts), tsNow = Settings.now();
        if (void 0 !== obj.year) {
            for (var _i = 0, _orderedUnits = orderedUnits; _i < _orderedUnits.length; _i++) {
                var u = _orderedUnits[_i];
                void 0 === obj[u] && (obj[u] = defaultUnitValues[u]);
            }
            var invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
            if (invalid) return DateTime.invalid(invalid);
            var invalid = objToTS(obj, zone.offset(tsNow), zone), ts = invalid[0], invalid = invalid[1];
        } else ts = tsNow;
        return new DateTime({
            ts: ts,
            zone: zone,
            loc: opts,
            o: invalid
        });
    }
    function diffRelative(start, end, opts) {
        function format(c, unit) {
            return c = roundTo(c, round || opts.calendary ? 0 : 2, !0), end.loc.clone(opts).relFormatter(opts).format(c, unit);
        }
        function differ(unit) {
            return opts.calendary ? end.hasSame(start, unit) ? 0 : end.startOf(unit).diff(start.startOf(unit), unit).get(unit) : end.diff(start, unit).get(unit);
        }
        var round = void 0 === opts.round || opts.round;
        if (opts.unit) return format(differ(opts.unit), opts.unit);
        for (var _iterator = _createForOfIteratorHelperLoose(opts.units); !(_step = _iterator()).done; ) {
            var _step = _step.value, count = differ(_step);
            if (1 <= Math.abs(count)) return format(count, _step);
        }
        return format(end < start ? -0 : 0, opts.units[opts.units.length - 1]);
    }
    function lastOpts(argList) {
        var opts = {}, argList = 0 < argList.length && "object" == typeof argList[argList.length - 1] ? (opts = argList[argList.length - 1], Array.from(argList).slice(0, argList.length - 1)) : Array.from(argList);
        return [ opts, argList ];
    }
    var DateTime = function() {
        function DateTime(config) {
            var _ref, zone = config.zone || Settings.defaultZone, invalid = config.invalid || (Number.isNaN(config.ts) ? new Invalid("invalid input") : null) || (zone.isValid ? null : unsupportedZone(zone)), c = (this.ts = void 0 === config.ts ? Settings.now() : config.ts, null), o = null;
            invalid || (o = config.old && config.old.ts === this.ts && config.old.zone.equals(zone) ? (c = (_ref = [ config.old.c, config.old.o ])[0], _ref[1]) : (_ref = zone.offset(this.ts), c = tsToObj(this.ts, _ref), c = (invalid = Number.isNaN(c.year) ? new Invalid("invalid input") : null) ? null : c, invalid ? null : _ref)), this._zone = zone, this.loc = config.loc || Locale.create(), this.invalid = invalid, this.weekData = null, this.c = c, this.o = o, this.isLuxonDateTime = !0;
        }
        DateTime.now = function() {
            return new DateTime({});
        }, DateTime.local = function() {
            var _lastOpts = lastOpts(arguments), opts = _lastOpts[0], _lastOpts = _lastOpts[1];
            return quickDT({
                year: _lastOpts[0],
                month: _lastOpts[1],
                day: _lastOpts[2],
                hour: _lastOpts[3],
                minute: _lastOpts[4],
                second: _lastOpts[5],
                millisecond: _lastOpts[6]
            }, opts);
        }, DateTime.utc = function() {
            var _lastOpts2 = lastOpts(arguments), opts = _lastOpts2[0], _lastOpts2 = _lastOpts2[1], year = _lastOpts2[0], month = _lastOpts2[1], day = _lastOpts2[2], hour = _lastOpts2[3], minute = _lastOpts2[4], second = _lastOpts2[5], _lastOpts2 = _lastOpts2[6];
            return opts.zone = FixedOffsetZone.utcInstance, quickDT({
                year: year,
                month: month,
                day: day,
                hour: hour,
                minute: minute,
                second: second,
                millisecond: _lastOpts2
            }, opts);
        }, DateTime.fromJSDate = function(date, options) {
            void 0 === options && (options = {});
            var zoneToUse, date = "[object Date]" === Object.prototype.toString.call(date) ? date.valueOf() : NaN;
            return Number.isNaN(date) ? DateTime.invalid("invalid input") : (zoneToUse = normalizeZone(options.zone, Settings.defaultZone)).isValid ? new DateTime({
                ts: date,
                zone: zoneToUse,
                loc: Locale.fromObject(options)
            }) : DateTime.invalid(unsupportedZone(zoneToUse));
        }, DateTime.fromMillis = function(milliseconds, options) {
            if (void 0 === options && (options = {}), isNumber(milliseconds)) return milliseconds < -864e13 || 864e13 < milliseconds ? DateTime.invalid("Timestamp out of range") : new DateTime({
                ts: milliseconds,
                zone: normalizeZone(options.zone, Settings.defaultZone),
                loc: Locale.fromObject(options)
            });
            throw new InvalidArgumentError("fromMillis requires a numerical input, but received a " + typeof milliseconds + " with value " + milliseconds);
        }, DateTime.fromSeconds = function(seconds, options) {
            if (void 0 === options && (options = {}), isNumber(seconds)) return new DateTime({
                ts: 1e3 * seconds,
                zone: normalizeZone(options.zone, Settings.defaultZone),
                loc: Locale.fromObject(options)
            });
            throw new InvalidArgumentError("fromSeconds requires a numerical input");
        }, DateTime.fromObject = function(obj, opts) {
            obj = obj || {};
            var zoneToUse = normalizeZone((opts = void 0 === opts ? {} : opts).zone, Settings.defaultZone);
            if (!zoneToUse.isValid) return DateTime.invalid(unsupportedZone(zoneToUse));
            var tsNow = Settings.now(), offsetProvis = void 0 !== opts.specificOffset ? opts.specificOffset : zoneToUse.offset(tsNow), normalized = normalizeObject(obj, normalizeUnit), containsOrdinal = !(void 0 === normalized.ordinal), containsGregorYear = !(void 0 === normalized.year), containsGregorMD = !(void 0 === normalized.month && void 0 === normalized.day), containsGregorYear = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber, opts = Locale.fromObject(opts);
            if ((containsGregorYear || containsOrdinal) && definiteWeekDef) throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
            if (containsGregorMD && containsOrdinal) throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
            for (var defaultValues, containsGregorMD = definiteWeekDef || normalized.weekday && !containsGregorYear, objNow = tsToObj(tsNow, offsetProvis), foundFirst = (containsGregorMD ? (units = orderedWeekUnits, defaultValues = defaultWeekUnitValues, objNow = gregorianToWeek(objNow)) : containsOrdinal ? (units = orderedOrdinalUnits, defaultValues = defaultOrdinalUnitValues, objNow = gregorianToOrdinal(objNow)) : (units = orderedUnits, defaultValues = defaultUnitValues), !1), _iterator2 = _createForOfIteratorHelperLoose(units); !(_step2 = _iterator2()).done; ) {
                var _step2 = _step2.value;
                void 0 !== normalized[_step2] ? foundFirst = !0 : normalized[_step2] = (foundFirst ? defaultValues : objNow)[_step2];
            }
            var units, definiteWeekDef = (containsGregorMD ? function(obj) {
                var validYear = isInteger(obj.weekYear), validWeek = integerBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear)), validWeekday = integerBetween(obj.weekday, 1, 7);
                return validYear ? validWeek ? !validWeekday && unitOutOfRange("weekday", obj.weekday) : unitOutOfRange("week", obj.week) : unitOutOfRange("weekYear", obj.weekYear);
            } : containsOrdinal ? function(obj) {
                var validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
                return validYear ? !validOrdinal && unitOutOfRange("ordinal", obj.ordinal) : unitOutOfRange("year", obj.year);
            } : hasInvalidGregorianData)(normalized) || hasInvalidTimeData(normalized);
            return definiteWeekDef ? DateTime.invalid(definiteWeekDef) : (units = new DateTime({
                ts: (tsNow = objToTS(containsGregorMD ? weekToGregorian(normalized) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, offsetProvis, zoneToUse))[0],
                zone: zoneToUse,
                o: tsNow[1],
                loc: opts
            }), normalized.weekday && containsGregorYear && obj.weekday !== units.weekday ? DateTime.invalid("mismatched weekday", "you can't specify both a weekday of " + normalized.weekday + " and a date of " + units.toISO()) : units);
        }, DateTime.fromISO = function(text, opts) {
            void 0 === opts && (opts = {});
            var _parseISODate = parse(text, [ isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset ], [ isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset ], [ isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime ], [ isoTimeCombinedRegex, extractISOTimeAndOffset ]);
            return parseDataToDateTime(_parseISODate[0], _parseISODate[1], opts, "ISO 8601", text);
        }, DateTime.fromRFC2822 = function(text, opts) {
            void 0 === opts && (opts = {});
            var _parseRFC2822Date = parse(text.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim(), [ rfc2822, extractRFC2822 ]);
            return parseDataToDateTime(_parseRFC2822Date[0], _parseRFC2822Date[1], opts, "RFC 2822", text);
        }, DateTime.fromHTTP = function(text, opts) {
            void 0 === opts && (opts = {});
            text = parse(text, [ rfc1123, extractRFC1123Or850 ], [ rfc850, extractRFC1123Or850 ], [ ascii, extractASCII ]);
            return parseDataToDateTime(text[0], text[1], opts, "HTTP", opts);
        }, DateTime.fromFormat = function(text, fmt, opts) {
            if (void 0 === opts && (opts = {}), void 0 === text || void 0 === fmt) throw new InvalidArgumentError("fromFormat requires an input string and a format");
            var _opts = opts, _opts$locale = _opts.locale, _opts = _opts.numberingSystem, _opts$locale = function(locale, input, format) {
                return [ (locale = explainFromTokens(locale, input, format)).result, locale.zone, locale.specificOffset, locale.invalidReason ];
            }(Locale.fromOpts({
                locale: void 0 === _opts$locale ? null : _opts$locale,
                numberingSystem: void 0 === _opts ? null : _opts,
                defaultToEN: !0
            }), text, fmt), _opts = _opts$locale[0], parsedZone = _opts$locale[1], specificOffset = _opts$locale[2], _opts$locale = _opts$locale[3];
            return _opts$locale ? DateTime.invalid(_opts$locale) : parseDataToDateTime(_opts, parsedZone, opts, "format " + fmt, text, specificOffset);
        }, DateTime.fromString = function(text, fmt, opts) {
            return DateTime.fromFormat(text, fmt, opts = void 0 === opts ? {} : opts);
        }, DateTime.fromSQL = function(text, opts) {
            void 0 === opts && (opts = {});
            var _parseSQL = parse(text, [ sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset ], [ sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone ]);
            return parseDataToDateTime(_parseSQL[0], _parseSQL[1], opts, "SQL", text);
        }, DateTime.invalid = function(reason, explanation) {
            if (void 0 === explanation && (explanation = null), !reason) throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
            reason = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
            if (Settings.throwOnInvalid) throw new InvalidDateTimeError(reason);
            return new DateTime({
                invalid: reason
            });
        }, DateTime.isDateTime = function(o) {
            return o && o.isLuxonDateTime || !1;
        }, DateTime.parseFormatForOpts = function(formatOpts, localeOpts) {
            formatOpts = formatOptsToTokens(formatOpts, Locale.fromObject(localeOpts = void 0 === localeOpts ? {} : localeOpts));
            return formatOpts ? formatOpts.map(function(t) {
                return t ? t.val : null;
            }).join("") : null;
        }, DateTime.expandFormat = function(fmt, localeOpts) {
            return void 0 === localeOpts && (localeOpts = {}), expandMacroTokens(Formatter.parseFormat(fmt), Locale.fromObject(localeOpts)).map(function(t) {
                return t.val;
            }).join("");
        };
        var _proto = DateTime.prototype;
        return _proto.get = function(unit) {
            return this[unit];
        }, _proto.getPossibleOffsets = function() {
            var localTS, ts2, oEarlier, oLater;
            return this.isValid && !this.isOffsetFixed && (localTS = objToLocalTS(this.c), oEarlier = this.zone.offset(localTS - 864e5), oLater = this.zone.offset(localTS + 864e5), (oEarlier = this.zone.offset(localTS - 6e4 * oEarlier)) !== (oLater = this.zone.offset(localTS - 6e4 * oLater))) && (ts2 = localTS - 6e4 * oLater, oEarlier = tsToObj(localTS = localTS - 6e4 * oEarlier, oEarlier), oLater = tsToObj(ts2, oLater), oEarlier.hour === oLater.hour) && oEarlier.minute === oLater.minute && oEarlier.second === oLater.second && oEarlier.millisecond === oLater.millisecond ? [ clone(this, {
                ts: localTS
            }), clone(this, {
                ts: ts2
            }) ] : [ this ];
        }, _proto.resolvedLocaleOptions = function(opts) {
            opts = Formatter.create(this.loc.clone(opts = void 0 === opts ? {} : opts), opts).resolvedOptions(this);
            return {
                locale: opts.locale,
                numberingSystem: opts.numberingSystem,
                outputCalendar: opts.calendar
            };
        }, _proto.toUTC = function(offset, opts) {
            return void 0 === opts && (opts = {}), this.setZone(FixedOffsetZone.instance(offset = void 0 === offset ? 0 : offset), opts);
        }, _proto.toLocal = function() {
            return this.setZone(Settings.defaultZone);
        }, _proto.setZone = function(zone, _temp) {
            var newTS, _temp = void 0 === _temp ? {} : _temp, _ref2$keepLocalTime = _temp.keepLocalTime, _ref2$keepLocalTime = void 0 !== _ref2$keepLocalTime && _ref2$keepLocalTime, _temp = _temp.keepCalendarTime, _temp = void 0 !== _temp && _temp;
            return (zone = normalizeZone(zone, Settings.defaultZone)).equals(this.zone) ? this : zone.isValid ? (newTS = this.ts, (_ref2$keepLocalTime || _temp) && (_ref2$keepLocalTime = zone.offset(this.ts), newTS = objToTS(this.toObject(), _ref2$keepLocalTime, zone)[0]), clone(this, {
                ts: newTS,
                zone: zone
            })) : DateTime.invalid(unsupportedZone(zone));
        }, _proto.reconfigure = function(_temp2) {
            var _temp2 = void 0 === _temp2 ? {} : _temp2, locale = _temp2.locale, numberingSystem = _temp2.numberingSystem, _temp2 = _temp2.outputCalendar, locale = this.loc.clone({
                locale: locale,
                numberingSystem: numberingSystem,
                outputCalendar: _temp2
            });
            return clone(this, {
                loc: locale
            });
        }, _proto.setLocale = function(locale) {
            return this.reconfigure({
                locale: locale
            });
        }, _proto.set = function(values) {
            if (!this.isValid) return this;
            var mixed, values = normalizeObject(values, normalizeUnit), settingWeekStuff = !(void 0 === values.weekYear && void 0 === values.weekNumber && void 0 === values.weekday), containsOrdinal = !(void 0 === values.ordinal), containsGregorYear = !(void 0 === values.year), containsGregorMD = !(void 0 === values.month && void 0 === values.day), definiteWeekDef = values.weekYear || values.weekNumber;
            if ((containsGregorYear || containsGregorMD || containsOrdinal) && definiteWeekDef) throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
            if (containsGregorMD && containsOrdinal) throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
            settingWeekStuff ? mixed = weekToGregorian(_extends({}, gregorianToWeek(this.c), values)) : void 0 !== values.ordinal ? mixed = ordinalToGregorian(_extends({}, gregorianToOrdinal(this.c), values)) : (mixed = _extends({}, this.toObject(), values), void 0 === values.day && (mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day)));
            containsGregorYear = objToTS(mixed, this.o, this.zone);
            return clone(this, {
                ts: containsGregorYear[0],
                o: containsGregorYear[1]
            });
        }, _proto.plus = function(duration) {
            return this.isValid ? clone(this, adjustTime(this, Duration.fromDurationLike(duration))) : this;
        }, _proto.minus = function(duration) {
            return this.isValid ? clone(this, adjustTime(this, Duration.fromDurationLike(duration).negate())) : this;
        }, _proto.startOf = function(unit) {
            if (!this.isValid) return this;
            var o = {}, unit = Duration.normalizeUnit(unit);
            switch (unit) {
              case "years":
                o.month = 1;

              case "quarters":
              case "months":
                o.day = 1;

              case "weeks":
              case "days":
                o.hour = 0;

              case "hours":
                o.minute = 0;

              case "minutes":
                o.second = 0;

              case "seconds":
                o.millisecond = 0;
            }
            return "weeks" === unit && (o.weekday = 1), "quarters" === unit && (unit = Math.ceil(this.month / 3), o.month = 3 * (unit - 1) + 1), this.set(o);
        }, _proto.endOf = function(unit) {
            var _this$plus;
            return this.isValid ? this.plus(((_this$plus = {})[unit] = 1, _this$plus)).startOf(unit).minus(1) : this;
        }, _proto.toFormat = function(fmt, opts) {
            return void 0 === opts && (opts = {}), this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID;
        }, _proto.toLocaleString = function(formatOpts, opts) {
            return void 0 === formatOpts && (formatOpts = DATE_SHORT), void 0 === opts && (opts = {}), this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID;
        }, _proto.toLocaleParts = function(opts) {
            return void 0 === opts && (opts = {}), this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
        }, _proto.toISO = function(_temp3) {
            var c, _temp3 = void 0 === _temp3 ? {} : _temp3, _ref4$format = _temp3.format, _ref4$suppressSeconds = _temp3.suppressSeconds, _ref4$suppressSeconds = void 0 !== _ref4$suppressSeconds && _ref4$suppressSeconds, _ref4$suppressMillise = _temp3.suppressMilliseconds, _ref4$suppressMillise = void 0 !== _ref4$suppressMillise && _ref4$suppressMillise, _ref4$includeOffset = _temp3.includeOffset, _ref4$includeOffset = void 0 === _ref4$includeOffset || _ref4$includeOffset, _temp3 = _temp3.extendedZone, _temp3 = void 0 !== _temp3 && _temp3;
            return this.isValid ? (c = _toISODate(this, _ref4$format = "extended" === (void 0 === _ref4$format ? "extended" : _ref4$format)), (c += "T") + _toISOTime(this, _ref4$format, _ref4$suppressSeconds, _ref4$suppressMillise, _ref4$includeOffset, _temp3)) : null;
        }, _proto.toISODate = function(_temp4) {
            _temp4 = (void 0 === _temp4 ? {} : _temp4).format;
            return this.isValid ? _toISODate(this, "extended" === (void 0 === _temp4 ? "extended" : _temp4)) : null;
        }, _proto.toISOWeekDate = function() {
            return toTechFormat(this, "kkkk-'W'WW-c");
        }, _proto.toISOTime = function(_temp5) {
            var _temp5 = void 0 === _temp5 ? {} : _temp5, _ref6$suppressMillise = _temp5.suppressMilliseconds, _ref6$suppressSeconds = _temp5.suppressSeconds, _ref6$includeOffset = _temp5.includeOffset, _ref6$includePrefix = _temp5.includePrefix, _ref6$extendedZone = _temp5.extendedZone, _temp5 = _temp5.format;
            return this.isValid ? (void 0 !== _ref6$includePrefix && _ref6$includePrefix ? "T" : "") + _toISOTime(this, "extended" === (void 0 === _temp5 ? "extended" : _temp5), void 0 !== _ref6$suppressSeconds && _ref6$suppressSeconds, void 0 !== _ref6$suppressMillise && _ref6$suppressMillise, void 0 === _ref6$includeOffset || _ref6$includeOffset, void 0 !== _ref6$extendedZone && _ref6$extendedZone) : null;
        }, _proto.toRFC2822 = function() {
            return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", !1);
        }, _proto.toHTTP = function() {
            return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
        }, _proto.toSQLDate = function() {
            return this.isValid ? _toISODate(this, !0) : null;
        }, _proto.toSQLTime = function(_temp6) {
            var _temp6 = void 0 === _temp6 ? {} : _temp6, _ref7$includeOffset = _temp6.includeOffset, _ref7$includeOffset = void 0 === _ref7$includeOffset || _ref7$includeOffset, _ref7$includeZone = _temp6.includeZone, _ref7$includeZone = void 0 !== _ref7$includeZone && _ref7$includeZone, _temp6 = _temp6.includeOffsetSpace, fmt = "HH:mm:ss.SSS";
            return (_ref7$includeZone || _ref7$includeOffset) && ((void 0 === _temp6 || _temp6) && (fmt += " "), _ref7$includeZone ? fmt += "z" : _ref7$includeOffset && (fmt += "ZZ")), toTechFormat(this, fmt, !0);
        }, _proto.toSQL = function(opts) {
            return void 0 === opts && (opts = {}), this.isValid ? this.toSQLDate() + " " + this.toSQLTime(opts) : null;
        }, _proto.toString = function() {
            return this.isValid ? this.toISO() : INVALID;
        }, _proto.valueOf = function() {
            return this.toMillis();
        }, _proto.toMillis = function() {
            return this.isValid ? this.ts : NaN;
        }, _proto.toSeconds = function() {
            return this.isValid ? this.ts / 1e3 : NaN;
        }, _proto.toUnixInteger = function() {
            return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
        }, _proto.toJSON = function() {
            return this.toISO();
        }, _proto.toBSON = function() {
            return this.toJSDate();
        }, _proto.toObject = function(opts) {
            var base;
            return void 0 === opts && (opts = {}), this.isValid ? (base = _extends({}, this.c), opts.includeConfig && (base.outputCalendar = this.outputCalendar, base.numberingSystem = this.loc.numberingSystem, base.locale = this.loc.locale), base) : {};
        }, _proto.toJSDate = function() {
            return new Date(this.isValid ? this.ts : NaN);
        }, _proto.diff = function(otherDateTime, unit, opts) {
            var otherIsLater;
            return void 0 === unit && (unit = "milliseconds"), void 0 === opts && (opts = {}), this.isValid && otherDateTime.isValid ? (opts = _extends({
                locale: this.locale,
                numberingSystem: this.numberingSystem
            }, opts), unit = unit, unit = (Array.isArray(unit) ? unit : [ unit ]).map(Duration.normalizeUnit), otherDateTime = _diff((otherIsLater = otherDateTime.valueOf() > this.valueOf()) ? this : otherDateTime, otherIsLater ? otherDateTime : this, unit, opts), otherIsLater ? otherDateTime.negate() : otherDateTime) : Duration.invalid("created by diffing an invalid DateTime");
        }, _proto.diffNow = function(unit, opts) {
            return void 0 === unit && (unit = "milliseconds"), void 0 === opts && (opts = {}), this.diff(DateTime.now(), unit, opts);
        }, _proto.until = function(otherDateTime) {
            return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
        }, _proto.hasSame = function(otherDateTime, unit) {
            var inputMs;
            return !!this.isValid && (inputMs = otherDateTime.valueOf(), (otherDateTime = this.setZone(otherDateTime.zone, {
                keepLocalTime: !0
            })).startOf(unit) <= inputMs) && inputMs <= otherDateTime.endOf(unit);
        }, _proto.equals = function(other) {
            return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
        }, _proto.toRelative = function(options) {
            var base, padding, units, unit;
            return this.isValid ? (base = (options = void 0 === options ? {} : options).base || DateTime.fromObject({}, {
                zone: this.zone
            }), padding = options.padding ? this < base ? -options.padding : options.padding : 0, units = [ "years", "months", "days", "hours", "minutes", "seconds" ], unit = options.unit, Array.isArray(options.unit) && (units = options.unit, unit = void 0), diffRelative(base, this.plus(padding), _extends({}, options, {
                numeric: "always",
                units: units,
                unit: unit
            }))) : null;
        }, _proto.toRelativeCalendar = function(options) {
            return void 0 === options && (options = {}), this.isValid ? diffRelative(options.base || DateTime.fromObject({}, {
                zone: this.zone
            }), this, _extends({}, options, {
                numeric: "auto",
                units: [ "years", "months", "days" ],
                calendary: !0
            })) : null;
        }, DateTime.min = function() {
            for (var _len = arguments.length, dateTimes = new Array(_len), _key = 0; _key < _len; _key++) dateTimes[_key] = arguments[_key];
            if (dateTimes.every(DateTime.isDateTime)) return bestBy(dateTimes, function(i) {
                return i.valueOf();
            }, Math.min);
            throw new InvalidArgumentError("min requires all arguments be DateTimes");
        }, DateTime.max = function() {
            for (var _len2 = arguments.length, dateTimes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) dateTimes[_key2] = arguments[_key2];
            if (dateTimes.every(DateTime.isDateTime)) return bestBy(dateTimes, function(i) {
                return i.valueOf();
            }, Math.max);
            throw new InvalidArgumentError("max requires all arguments be DateTimes");
        }, DateTime.fromFormatExplain = function(text, fmt, options) {
            var options = options = void 0 === options ? {} : options, _options$locale = options.locale, options = options.numberingSystem;
            return explainFromTokens(Locale.fromOpts({
                locale: void 0 === _options$locale ? null : _options$locale,
                numberingSystem: void 0 === options ? null : options,
                defaultToEN: !0
            }), text, fmt);
        }, DateTime.fromStringExplain = function(text, fmt, options) {
            return DateTime.fromFormatExplain(text, fmt, options = void 0 === options ? {} : options);
        }, _createClass(DateTime, [ {
            key: "isValid",
            get: function() {
                return null === this.invalid;
            }
        }, {
            key: "invalidReason",
            get: function() {
                return this.invalid ? this.invalid.reason : null;
            }
        }, {
            key: "invalidExplanation",
            get: function() {
                return this.invalid ? this.invalid.explanation : null;
            }
        }, {
            key: "locale",
            get: function() {
                return this.isValid ? this.loc.locale : null;
            }
        }, {
            key: "numberingSystem",
            get: function() {
                return this.isValid ? this.loc.numberingSystem : null;
            }
        }, {
            key: "outputCalendar",
            get: function() {
                return this.isValid ? this.loc.outputCalendar : null;
            }
        }, {
            key: "zone",
            get: function() {
                return this._zone;
            }
        }, {
            key: "zoneName",
            get: function() {
                return this.isValid ? this.zone.name : null;
            }
        }, {
            key: "year",
            get: function() {
                return this.isValid ? this.c.year : NaN;
            }
        }, {
            key: "quarter",
            get: function() {
                return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
            }
        }, {
            key: "month",
            get: function() {
                return this.isValid ? this.c.month : NaN;
            }
        }, {
            key: "day",
            get: function() {
                return this.isValid ? this.c.day : NaN;
            }
        }, {
            key: "hour",
            get: function() {
                return this.isValid ? this.c.hour : NaN;
            }
        }, {
            key: "minute",
            get: function() {
                return this.isValid ? this.c.minute : NaN;
            }
        }, {
            key: "second",
            get: function() {
                return this.isValid ? this.c.second : NaN;
            }
        }, {
            key: "millisecond",
            get: function() {
                return this.isValid ? this.c.millisecond : NaN;
            }
        }, {
            key: "weekYear",
            get: function() {
                return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
            }
        }, {
            key: "weekNumber",
            get: function() {
                return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
            }
        }, {
            key: "weekday",
            get: function() {
                return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
            }
        }, {
            key: "ordinal",
            get: function() {
                return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
            }
        }, {
            key: "monthShort",
            get: function() {
                return this.isValid ? Info.months("short", {
                    locObj: this.loc
                })[this.month - 1] : null;
            }
        }, {
            key: "monthLong",
            get: function() {
                return this.isValid ? Info.months("long", {
                    locObj: this.loc
                })[this.month - 1] : null;
            }
        }, {
            key: "weekdayShort",
            get: function() {
                return this.isValid ? Info.weekdays("short", {
                    locObj: this.loc
                })[this.weekday - 1] : null;
            }
        }, {
            key: "weekdayLong",
            get: function() {
                return this.isValid ? Info.weekdays("long", {
                    locObj: this.loc
                })[this.weekday - 1] : null;
            }
        }, {
            key: "offset",
            get: function() {
                return this.isValid ? +this.o : NaN;
            }
        }, {
            key: "offsetNameShort",
            get: function() {
                return this.isValid ? this.zone.offsetName(this.ts, {
                    format: "short",
                    locale: this.locale
                }) : null;
            }
        }, {
            key: "offsetNameLong",
            get: function() {
                return this.isValid ? this.zone.offsetName(this.ts, {
                    format: "long",
                    locale: this.locale
                }) : null;
            }
        }, {
            key: "isOffsetFixed",
            get: function() {
                return this.isValid ? this.zone.isUniversal : null;
            }
        }, {
            key: "isInDST",
            get: function() {
                return !this.isOffsetFixed && (this.offset > this.set({
                    month: 1,
                    day: 1
                }).offset || this.offset > this.set({
                    month: 5
                }).offset);
            }
        }, {
            key: "isInLeapYear",
            get: function() {
                return isLeapYear(this.year);
            }
        }, {
            key: "daysInMonth",
            get: function() {
                return daysInMonth(this.year, this.month);
            }
        }, {
            key: "daysInYear",
            get: function() {
                return this.isValid ? daysInYear(this.year) : NaN;
            }
        }, {
            key: "weeksInWeekYear",
            get: function() {
                return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
            }
        } ], [ {
            key: "DATE_SHORT",
            get: function() {
                return DATE_SHORT;
            }
        }, {
            key: "DATE_MED",
            get: function() {
                return DATE_MED;
            }
        }, {
            key: "DATE_MED_WITH_WEEKDAY",
            get: function() {
                return DATE_MED_WITH_WEEKDAY;
            }
        }, {
            key: "DATE_FULL",
            get: function() {
                return DATE_FULL;
            }
        }, {
            key: "DATE_HUGE",
            get: function() {
                return DATE_HUGE;
            }
        }, {
            key: "TIME_SIMPLE",
            get: function() {
                return TIME_SIMPLE;
            }
        }, {
            key: "TIME_WITH_SECONDS",
            get: function() {
                return TIME_WITH_SECONDS;
            }
        }, {
            key: "TIME_WITH_SHORT_OFFSET",
            get: function() {
                return TIME_WITH_SHORT_OFFSET;
            }
        }, {
            key: "TIME_WITH_LONG_OFFSET",
            get: function() {
                return TIME_WITH_LONG_OFFSET;
            }
        }, {
            key: "TIME_24_SIMPLE",
            get: function() {
                return TIME_24_SIMPLE;
            }
        }, {
            key: "TIME_24_WITH_SECONDS",
            get: function() {
                return TIME_24_WITH_SECONDS;
            }
        }, {
            key: "TIME_24_WITH_SHORT_OFFSET",
            get: function() {
                return TIME_24_WITH_SHORT_OFFSET;
            }
        }, {
            key: "TIME_24_WITH_LONG_OFFSET",
            get: function() {
                return TIME_24_WITH_LONG_OFFSET;
            }
        }, {
            key: "DATETIME_SHORT",
            get: function() {
                return DATETIME_SHORT;
            }
        }, {
            key: "DATETIME_SHORT_WITH_SECONDS",
            get: function() {
                return DATETIME_SHORT_WITH_SECONDS;
            }
        }, {
            key: "DATETIME_MED",
            get: function() {
                return DATETIME_MED;
            }
        }, {
            key: "DATETIME_MED_WITH_SECONDS",
            get: function() {
                return DATETIME_MED_WITH_SECONDS;
            }
        }, {
            key: "DATETIME_MED_WITH_WEEKDAY",
            get: function() {
                return DATETIME_MED_WITH_WEEKDAY;
            }
        }, {
            key: "DATETIME_FULL",
            get: function() {
                return DATETIME_FULL;
            }
        }, {
            key: "DATETIME_FULL_WITH_SECONDS",
            get: function() {
                return DATETIME_FULL_WITH_SECONDS;
            }
        }, {
            key: "DATETIME_HUGE",
            get: function() {
                return DATETIME_HUGE;
            }
        }, {
            key: "DATETIME_HUGE_WITH_SECONDS",
            get: function() {
                return DATETIME_HUGE_WITH_SECONDS;
            }
        } ]), DateTime;
    }();
    function friendlyDateTime(dateTimeish) {
        if (DateTime.isDateTime(dateTimeish)) return dateTimeish;
        if (dateTimeish && dateTimeish.valueOf && isNumber(dateTimeish.valueOf())) return DateTime.fromJSDate(dateTimeish);
        if (dateTimeish && "object" == typeof dateTimeish) return DateTime.fromObject(dateTimeish);
        throw new InvalidArgumentError("Unknown datetime argument: " + dateTimeish + ", of type " + typeof dateTimeish);
    }
    _$luxon_9.DateTime = DateTime;
    var _$constants_3 = {}, _$utils_8 = (Object.defineProperty(_$constants_3, "__esModule", {
        value: !0
    }), _$constants_3.RE_RANGE = _$constants_3.RE_WILDCARDS = _$constants_3.PRESETS = _$constants_3.TIME_UNITS_LEN = _$constants_3.TIME_UNITS = _$constants_3.TIME_UNITS_MAP = _$constants_3.ALIASES = _$constants_3.PARSE_DEFAULTS = _$constants_3.MONTH_CONSTRAINTS = _$constants_3.CONSTRAINTS = void 0, _$constants_3.CONSTRAINTS = Object.freeze({
        second: [ 0, 59 ],
        minute: [ 0, 59 ],
        hour: [ 0, 23 ],
        dayOfMonth: [ 1, 31 ],
        month: [ 1, 12 ],
        dayOfWeek: [ 0, 7 ]
    }), _$constants_3.MONTH_CONSTRAINTS = Object.freeze({
        1: 31,
        2: 29,
        3: 31,
        4: 30,
        5: 31,
        6: 30,
        7: 31,
        8: 31,
        9: 30,
        10: 31,
        11: 30,
        12: 31
    }), _$constants_3.PARSE_DEFAULTS = Object.freeze({
        second: "0",
        minute: "*",
        hour: "*",
        dayOfMonth: "*",
        month: "*",
        dayOfWeek: "*"
    }), _$constants_3.ALIASES = Object.freeze({
        jan: 1,
        feb: 2,
        mar: 3,
        apr: 4,
        may: 5,
        jun: 6,
        jul: 7,
        aug: 8,
        sep: 9,
        oct: 10,
        nov: 11,
        dec: 12,
        sun: 0,
        mon: 1,
        tue: 2,
        wed: 3,
        thu: 4,
        fri: 5,
        sat: 6
    }), _$constants_3.TIME_UNITS_MAP = Object.freeze({
        SECOND: "second",
        MINUTE: "minute",
        HOUR: "hour",
        DAY_OF_MONTH: "dayOfMonth",
        MONTH: "month",
        DAY_OF_WEEK: "dayOfWeek"
    }), _$constants_3.TIME_UNITS = Object.freeze(Object.values(_$constants_3.TIME_UNITS_MAP)), _$constants_3.TIME_UNITS_LEN = _$constants_3.TIME_UNITS.length, _$constants_3.PRESETS = Object.freeze({
        "@yearly": "0 0 0 1 1 *",
        "@monthly": "0 0 0 1 * *",
        "@weekly": "0 0 0 * * 0",
        "@daily": "0 0 0 * * *",
        "@hourly": "0 0 * * * *",
        "@minutely": "0 * * * * *",
        "@secondly": "* * * * * *",
        "@weekdays": "0 0 0 * * 1-5",
        "@weekends": "0 0 0 * * 0,6"
    }), _$constants_3.RE_WILDCARDS = /\*/g, _$constants_3.RE_RANGE = /^(\d+)(?:-(\d+))?(?:\/(\d+))?$/g, {}), _$time_7 = (Object.defineProperty(_$utils_8, "__esModule", {
        value: !0
    }), _$utils_8.getRecordKeys = void 0, _$utils_8.getRecordKeys = record => Object.keys(record), {});
    Object.defineProperty(_$time_7, "__esModule", {
        value: !0
    }), _$time_7.CronTime = void 0;
    _$time_7.CronTime = class {
        constructor(source, timeZone, utcOffset) {
            if (this.realDate = !1, this.second = {}, this.minute = {}, this.hour = {}, this.dayOfMonth = {}, this.month = {}, this.dayOfWeek = {}, null != timeZone && null != utcOffset) throw new _$errors_4.ExclusiveParametersError("timeZone", "utcOffset");
            if (timeZone) {
                if (!_$luxon_9.DateTime.fromObject({}, {
                    zone: timeZone
                }).isValid) throw new Error("Invalid timezone.");
                this.timeZone = timeZone;
            }
            null != utcOffset && (this.utcOffset = utcOffset), source instanceof Date || source instanceof _$luxon_9.DateTime ? (this.source = source instanceof Date ? _$luxon_9.DateTime.fromJSDate(source) : source, this.realDate = !0) : (this.source = source, this._parse(this.source), this._verifyParse());
        }
        _getWeekDay(date) {
            return 7 === date.weekday ? 0 : date.weekday;
        }
        _verifyParse() {
            var months = (0, _$utils_8.getRecordKeys)(this.month), daysOfMonth = (0, _$utils_8.getRecordKeys)(this.dayOfMonth);
            let isOk = !1, lastWrongMonth = null;
            for (const m of months) {
                var con = _$constants_3.MONTH_CONSTRAINTS[m];
                for (const day of daysOfMonth) day <= con && (isOk = !0);
                isOk || (lastWrongMonth = m, console.warn(`Month '${m}' is limited to '${con}' days.`));
            }
            if (!isOk && null !== lastWrongMonth) {
                var fixedDay, notOkCon = _$constants_3.MONTH_CONSTRAINTS[lastWrongMonth];
                for (const notOkDay of daysOfMonth) notOkDay > notOkCon && (delete this.dayOfMonth[notOkDay], fixedDay = notOkDay % notOkCon, this.dayOfMonth[fixedDay] = !0);
            }
        }
        sendAt(i) {
            let date = this.realDate && this.source instanceof _$luxon_9.DateTime ? this.source : _$luxon_9.DateTime.local();
            if (this.timeZone && (date = date.setZone(this.timeZone)), void 0 !== this.utcOffset) {
                var sign = this.utcOffset < 0 ? "-" : "+", offsetHours = Math.trunc(this.utcOffset / 60), offsetHoursStr = String(Math.abs(offsetHours)).padStart(2, "0"), offsetHours = Math.abs(this.utcOffset - 60 * offsetHours), offsetHours = String(offsetHours).padStart(2, "0");
                if (!(date = date.setZone(`UTC${sign}${offsetHoursStr}:` + offsetHours)).isValid) throw new Error("ERROR: You specified an invalid UTC offset.");
            }
            if (this.realDate) {
                if (_$luxon_9.DateTime.local() > date) throw new Error("WARNING: Date in past. Will never be fired.");
                return date;
            }
            if (void 0 === i || isNaN(i) || i < 0) return this.getNextDateFrom(date);
            for (var dates = []; 0 < i; i--) date = this.getNextDateFrom(date), dates.push(date);
            return dates;
        }
        getTimeout() {
            return Math.max(-1, this.sendAt().toMillis() - _$luxon_9.DateTime.local().toMillis());
        }
        toString() {
            return this.toJSON().join(" ");
        }
        toJSON() {
            return _$constants_3.TIME_UNITS.map(unit => this._wcOrAll(unit));
        }
        getNextDateFrom(start, timeZone) {
            let date = start = start instanceof Date ? _$luxon_9.DateTime.fromJSDate(start) : start;
            var firstDate = start.toMillis();
            if (timeZone && (date = date.setZone(timeZone)), this.realDate || 0 < date.millisecond && (date = date.set({
                millisecond: 0,
                second: date.second + 1
            })), !date.isValid) throw new Error("ERROR: You specified an invalid date.");
            for (var maxMatch = _$luxon_9.DateTime.now().plus({
                years: 8
            }); ;) {
                var diff = date.toMillis() - start.toMillis();
                if (date > maxMatch) throw new Error(`Something went wrong. No execution date was found in the next 8 years.
							Please provide the following string if you would like to help debug:
							Time Zone: ${null != (_a = null == timeZone ? void 0 : timeZone.toString()) ? _a : '""'} - Cron String: ${this.source.toString()} - UTC offset: ${date.offset} - current Date: ` + _$luxon_9.DateTime.local().toString());
                if (date.month in this.month || 12 === Object.keys(this.month).length) {
                    if (date.day in this.dayOfMonth || 31 === Object.keys(this.dayOfMonth).length || this._getWeekDay(date) in this.dayOfWeek && 7 !== Object.keys(this.dayOfWeek).length) {
                        if (this._getWeekDay(date) in this.dayOfWeek || 7 === Object.keys(this.dayOfWeek).length || date.day in this.dayOfMonth && 31 !== Object.keys(this.dayOfMonth).length) if (date.hour in this.hour || 24 === Object.keys(this.hour).length) if (date.minute in this.minute || 60 === Object.keys(this.minute).length) if (date.second in this.second || 60 === Object.keys(this.second).length) {
                            if (date.toMillis() !== firstDate) break;
                            {
                                const expectedSecond = date.second + 1, expectedMinute = date.minute + (60 === expectedSecond ? 1 : 0), expectedHour = date.hour + (60 === expectedMinute ? 1 : 0);
                                if (date = date.set({
                                    second: expectedSecond
                                }), this._forwardDSTJump(expectedHour, expectedMinute, date)) {
                                    const [ isDone, newDate ] = this._findPreviousDSTJump(date);
                                    if (date = newDate, isDone) break;
                                }
                            }
                        } else {
                            var _a = 59 === date.second && 6e4 < diff ? 0 : date.second + 1;
                            const expectedMinute = date.minute + (60 === _a ? 1 : 0), expectedHour = date.hour + (60 === expectedMinute ? 1 : 0);
                            if (date = date.set({
                                second: _a
                            }), this._forwardDSTJump(expectedHour, expectedMinute, date)) {
                                const [ isDone, newDate ] = this._findPreviousDSTJump(date);
                                if (date = newDate, isDone) break;
                            }
                        } else {
                            const expectedMinute = 59 === date.minute && 36e5 < diff ? 0 : date.minute + 1, expectedHour = date.hour + (60 === expectedMinute ? 1 : 0);
                            if (date = (date = date.set({
                                minute: expectedMinute
                            })).set({
                                second: 0
                            }), this._forwardDSTJump(expectedHour, expectedMinute, date)) {
                                const [ isDone, newDate ] = this._findPreviousDSTJump(date);
                                if (date = newDate, isDone) break;
                            }
                        } else {
                            var diff = 23 === date.hour && 864e5 < diff ? 0 : date.hour + 1, expectedMinute = date.minute;
                            if (date = (date = date.set({
                                hour: diff
                            })).set({
                                minute: 0,
                                second: 0
                            }), this._forwardDSTJump(diff, expectedMinute, date)) {
                                const [ isDone, newDate ] = this._findPreviousDSTJump(date);
                                if (date = newDate, isDone) break;
                            }
                        } else if (date = (date = date.plus({
                            days: 1
                        })).set({
                            hour: 0,
                            minute: 0,
                            second: 0
                        }), this._forwardDSTJump(0, 0, date)) {
                            const [ isDone, newDate ] = this._findPreviousDSTJump(date);
                            if (date = newDate, isDone) break;
                        }
                    } else if (date = (date = date.plus({
                        days: 1
                    })).set({
                        hour: 0,
                        minute: 0,
                        second: 0
                    }), this._forwardDSTJump(0, 0, date)) {
                        const [ isDone, newDate ] = this._findPreviousDSTJump(date);
                        if (date = newDate, isDone) break;
                    }
                } else if (date = (date = date.plus({
                    months: 1
                })).set({
                    day: 1,
                    hour: 0,
                    minute: 0,
                    second: 0
                }), this._forwardDSTJump(0, 0, date)) {
                    var [ diff, expectedMinute ] = this._findPreviousDSTJump(date);
                    if (date = expectedMinute, diff) break;
                }
            }
            return date;
        }
        _findPreviousDSTJump(date) {
            var _a;
            let expectedMinute, expectedHour, actualMinute, actualHour, maybeJumpingPoint = date;
            let iteration = 0;
            do {
                if (1440 < ++iteration) throw new Error(`ERROR: This DST checking related function assumes the input DateTime (${null != (_a = date.toISO()) ? _a : date.toMillis()}) is within 24 hours of a DST jump.`);
            } while (expectedMinute = maybeJumpingPoint.minute - 1, expectedHour = maybeJumpingPoint.hour, expectedMinute < 0 && (expectedMinute += 60, expectedHour = (expectedHour + 24 - 1) % 24), actualMinute = (maybeJumpingPoint = maybeJumpingPoint.minus({
                minute: 1
            })).minute, actualHour = maybeJumpingPoint.hour, expectedMinute === actualMinute && expectedHour === actualHour);
            var afterJumpingPoint = maybeJumpingPoint.plus({
                minute: 1
            }).set({
                second: 0,
                millisecond: 0
            }), beforeJumpingPoint = afterJumpingPoint.minus({
                second: 1
            });
            return date.month + 1 in this.month && date.day in this.dayOfMonth && this._getWeekDay(date) in this.dayOfWeek ? [ this._checkTimeInSkippedRange(beforeJumpingPoint, afterJumpingPoint), afterJumpingPoint ] : [ !1, afterJumpingPoint ];
        }
        _checkTimeInSkippedRange(beforeJumpingPoint, afterJumpingPoint) {
            var startingMinute = (beforeJumpingPoint.minute + 1) % 60, beforeJumpingPoint = (beforeJumpingPoint.hour + (0 == startingMinute ? 1 : 0)) % 24, hourRangeSize = afterJumpingPoint.hour - beforeJumpingPoint + 1, isHourJump = 0 == startingMinute && 0 === afterJumpingPoint.minute;
            return 2 == hourRangeSize && isHourJump ? beforeJumpingPoint in this.hour : 1 == hourRangeSize ? beforeJumpingPoint in this.hour && this._checkTimeInSkippedRangeSingleHour(startingMinute, afterJumpingPoint.minute) : this._checkTimeInSkippedRangeMultiHour(beforeJumpingPoint, startingMinute, afterJumpingPoint.hour, afterJumpingPoint.minute);
        }
        _checkTimeInSkippedRangeSingleHour(startMinute, endMinute) {
            for (let minute = startMinute; minute < endMinute; ++minute) if (minute in this.minute) return !0;
            return endMinute in this.minute && 0 in this.second;
        }
        _checkTimeInSkippedRangeMultiHour(startHour, startMinute, endHour, endMinute) {
            if (endHour <= startHour) throw new Error(`ERROR: This DST checking related function assumes the forward jump starting hour (${startHour}) is less than the end hour (${endHour})`);
            const firstHourMinuteRange = Array.from({
                length: 60 - startMinute
            }, (_, k) => startMinute + k), lastHourMinuteRange = Array.from({
                length: endMinute
            }, (_, k) => k), middleHourMinuteRange = Array.from({
                length: 60
            }, (_, k) => k);
            for (let hour = startHour; hour <= endHour; ++hour) if (hour in this.hour) {
                var forHour = (forHour = hour) === startHour ? firstHourMinuteRange : forHour === endHour ? lastHourMinuteRange : middleHourMinuteRange;
                for (const minute of forHour) if (minute in this.minute) return !0;
            }
            return endHour in this.hour && endMinute in this.minute && 0 in this.second;
        }
        _forwardDSTJump(expectedHour, expectedMinute, actualDate) {
            var actualHour = actualDate.hour, actualDate = actualDate.minute;
            return expectedHour % 24 < actualHour || expectedMinute % 60 < actualDate;
        }
        _wcOrAll(unit) {
            if (this._hasAll(unit)) return "*";
            var all = [];
            for (const time in this[unit]) all.push(time);
            return all.join(",");
        }
        _hasAll(unit) {
            var constraints = _$constants_3.CONSTRAINTS[unit];
            for (let i = constraints[0], n = unit === _$constants_3.TIME_UNITS_MAP.DAY_OF_WEEK ? constraints[1] - 1 : constraints[1]; i < n; i++) if (!(i in this[unit])) return !1;
            return !0;
        }
        _parse(source) {
            source = source.toLowerCase();
            var units = (source = (source = Object.keys(_$constants_3.PRESETS).includes(source) ? _$constants_3.PRESETS[source] : source).replace(/[a-z]{1,3}/gi, alias => {
                if (Object.keys(_$constants_3.ALIASES).includes(alias)) return _$constants_3.ALIASES[alias].toString();
                throw new Error("Unknown alias: " + alias);
            })).trim().split(/\s+/);
            if (units.length < _$constants_3.TIME_UNITS_LEN - 1) throw new Error("Too few fields");
            if (units.length > _$constants_3.TIME_UNITS_LEN) throw new Error("Too many fields");
            var unitsLen = units.length;
            for (const unit of _$constants_3.TIME_UNITS) {
                var _a = null != (_a = units[_$constants_3.TIME_UNITS.indexOf(unit) - (_$constants_3.TIME_UNITS_LEN - unitsLen)]) ? _a : _$constants_3.PARSE_DEFAULTS[unit];
                this._parseField(_a, unit);
            }
        }
        _parseField(value, unit) {
            var typeObj = this[unit];
            let pointer;
            var constraints = _$constants_3.CONSTRAINTS[unit], low = constraints[0], high = constraints[1], constraints = (value.split(",").forEach(field => {
                var wildcardIndex = field.indexOf("*");
                if (-1 !== wildcardIndex && 0 !== wildcardIndex) throw new Error(`Field (${field}) has an invalid wildcard expression`);
            }), (value = value.replace(_$constants_3.RE_WILDCARDS, low + "-" + high)).split(","));
            for (const range of constraints) {
                var match = [ ...range.matchAll(_$constants_3.RE_RANGE) ][0];
                if (void 0 === (null == match ? void 0 : match[1])) throw new Error(`Field (${unit}) cannot be parsed`);
                {
                    var [ , match, mUpper, mStep ] = match, match = parseInt(match, 10);
                    let upper = void 0 !== mUpper ? parseInt(mUpper, 10) : void 0;
                    mUpper = void 0 !== mStep;
                    if ("0" === mStep) throw new Error(`Field (${unit}) has a step of zero`);
                    var step = parseInt(null != mStep ? mStep : "1", 10);
                    if (void 0 !== upper && match > upper) throw new Error(`Field (${unit}) has an invalid range`);
                    if (match < low || void 0 !== upper && upper > high || void 0 === upper && high < match) throw new Error(`Field value (${value}) is out of range`);
                    for (match = Math.min(Math.max(low, ~~Math.abs(match)), high), upper = void 0 !== upper ? Math.min(high, ~~Math.abs(upper)) : mUpper ? high : match, pointer = match; typeObj[pointer] = !0, (pointer += step) <= upper; );
                    "dayOfWeek" === unit && (!typeObj[0] && typeObj[7] && (typeObj[0] = typeObj[7]), delete typeObj[7]);
                }
            }
        }
    };
    var _$job_6 = {};
    Object.defineProperty(_$job_6, "__esModule", {
        value: !0
    }), _$job_6.CronJob = void 0;
    _$job_6.CronJob = class CronJob {
        constructor(cronTime, onTick, onComplete, start, timeZone, context, runOnInit, utcOffset, unrefTimeout) {
            if (this.running = !1, this.unrefTimeout = !1, this.lastExecution = null, this.runOnce = !1, this._callbacks = [], this.context = null != context ? context : this, null != timeZone && null != utcOffset) throw new _$errors_4.ExclusiveParametersError("timeZone", "utcOffset");
            this.cronTime = null != timeZone ? new _$time_7.CronTime(cronTime, timeZone, null) : null != utcOffset ? new _$time_7.CronTime(cronTime, null, utcOffset) : new _$time_7.CronTime(cronTime, timeZone, utcOffset), null != unrefTimeout && (this.unrefTimeout = unrefTimeout), null != onComplete && (this.onComplete = this._fnWrap(onComplete)), this.cronTime.realDate && (this.runOnce = !0), this.addCallback(this._fnWrap(onTick)), runOnInit && (this.lastExecution = new Date(), this.fireOnTick()), start && this.start();
        }
        static from(params) {
            if (null != params.timeZone && null != params.utcOffset) throw new _$errors_4.ExclusiveParametersError("timeZone", "utcOffset");
            return null == params.timeZone && null != params.utcOffset ? new CronJob(params.cronTime, params.onTick, params.onComplete, params.start, null, params.context, params.runOnInit, params.utcOffset, params.unrefTimeout) : new CronJob(params.cronTime, params.onTick, params.onComplete, params.start, params.timeZone, params.context, params.runOnInit, params.utcOffset, params.unrefTimeout);
        }
        _fnWrap(cmd) {
            switch (typeof cmd) {
              case "function":
                return cmd;

              case "string":
                var [ command, ...args ] = cmd.split(" ");
                return _$_empty_2.spawn.bind(void 0, null != command ? command : cmd, args, {});

              case "object":
                return _$_empty_2.spawn.bind(void 0, cmd.command, null != (command = cmd.args) ? command : [], null != (args = cmd.options) ? args : {});
            }
        }
        addCallback(callback) {
            "function" == typeof callback && this._callbacks.push(callback);
        }
        setTime(time) {
            if (!(time instanceof _$time_7.CronTime)) throw new Error("time must be an instance of CronTime.");
            var wasRunning = this.running;
            this.stop(), this.cronTime = time, wasRunning && this.start();
        }
        nextDate() {
            return this.cronTime.sendAt();
        }
        fireOnTick() {
            for (const callback of this._callbacks) callback.call(this.context, this.onComplete);
        }
        nextDates(i) {
            return this.cronTime.sendAt(null != i ? i : 0);
        }
        start() {
            if (this.running) return;
            const MAXDELAY = 2147483647;
            let timeout = this.cronTime.getTimeout(), remaining = 0, startTime;
            const setCronTimeout = t => {
                startTime = Date.now(), this._timeout = setTimeout(callbackWrapper, t), this.unrefTimeout && "function" == typeof this._timeout.unref && this._timeout.unref();
            }, callbackWrapper = () => {
                var diff = startTime + timeout - Date.now();
                if (0 < diff) {
                    let newTimeout = this.cronTime.getTimeout();
                    newTimeout > diff && (newTimeout = diff), remaining += newTimeout;
                }
                remaining ? (remaining > MAXDELAY ? (remaining -= MAXDELAY, timeout = MAXDELAY) : (timeout = remaining, remaining = 0), setCronTimeout(timeout)) : (this.lastExecution = new Date(), this.running = !1, this.runOnce || this.start(), this.fireOnTick());
            };
            0 <= timeout ? (this.running = !0, timeout > MAXDELAY && (remaining = timeout - MAXDELAY, timeout = MAXDELAY), setCronTimeout(timeout)) : this.stop();
        }
        lastDate() {
            return this.lastExecution;
        }
        stop() {
            this._timeout && clearTimeout(this._timeout), this.running = !1, "function" == typeof this.onComplete && this.onComplete.call(this.context);
        }
    };
    var _$dist_5 = {};
    Object.defineProperty(_$dist_5, "__esModule", {
        value: !0
    }), _$dist_5.timeout = _$dist_5.sendAt = _$dist_5.CronTime = _$dist_5.CronJob = void 0, Object.defineProperty(_$dist_5, "CronJob", {
        enumerable: !0,
        get: function() {
            return _$job_6.CronJob;
        }
    }), Object.defineProperty(_$dist_5, "CronTime", {
        enumerable: !0,
        get: function() {
            return _$time_7.CronTime;
        }
    }), _$dist_5.sendAt = cronTime => new _$time_7.CronTime(cronTime).sendAt(), _$dist_5.timeout = cronTime => new _$time_7.CronTime(cronTime).getTimeout();
    !function(global) {
        !function() {
            "use strict";
            var m = function(obj, nodeInterop) {
                if (!nodeInterop && obj && obj.__esModule) return obj;
                if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
                    default: obj
                };
                nodeInterop = _getRequireWildcardCache(nodeInterop);
                if (nodeInterop && nodeInterop.has(obj)) return nodeInterop.get(obj);
                var key, newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
                for (key in obj) {
                    var desc;
                    "default" !== key && Object.prototype.hasOwnProperty.call(obj, key) && ((desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null) && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key]);
                }
                newObj.default = obj, nodeInterop && nodeInterop.set(obj, newObj);
                return newObj;
            }(_$dist_5);
            function _getRequireWildcardCache(nodeInterop) {
                var cacheBabelInterop, cacheNodeInterop;
                return "function" != typeof WeakMap ? null : (cacheBabelInterop = new WeakMap(), cacheNodeInterop = new WeakMap(), (_getRequireWildcardCache = function(nodeInterop) {
                    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
                })(nodeInterop));
            }
            global.Cron = m;
        }.call(this);
    }.call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
}();
