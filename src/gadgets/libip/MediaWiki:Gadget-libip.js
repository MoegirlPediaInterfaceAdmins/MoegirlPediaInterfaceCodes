/**
 * Generated by scripts/browserify/index.js
 * Options:
 *     module: "ip"
 *     entry: "libip"
 *     gadget: { "name": "libip", "fileName": "MediaWiki:Gadget-libip.js" }
 */
!function() {
    t = function(module, exports) {
        !function(Buffer) {
            !function() {
                exports.Buffer = Buffer, exports.INSPECT_MAX_BYTES = 50;
                var K_MAX_LENGTH = 2147483647;
                function createBuffer(length) {
                    if (K_MAX_LENGTH < length) throw new RangeError('The value "' + length + '" is invalid for option "size"');
                    length = new Uint8Array(length);
                    return length.__proto__ = Buffer.prototype, length;
                }
                function Buffer(arg, encodingOrOffset, length) {
                    if ("number" != typeof arg) return from(arg, encodingOrOffset, length);
                    if ("string" == typeof encodingOrOffset) throw new TypeError('The "string" argument must be of type string. Received type number');
                    return allocUnsafe(arg);
                }
                function from(value, encodingOrOffset, length) {
                    if ("string" == typeof value) return function(string, encoding) {
                        "string" == typeof encoding && "" !== encoding || (encoding = "utf8");
                        if (!Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
                        var length = 0 | byteLength(string, encoding), buf = createBuffer(length), string = buf.write(string, encoding);
                        string !== length && (buf = buf.slice(0, string));
                        return buf;
                    }(value, encodingOrOffset);
                    if (ArrayBuffer.isView(value)) return fromArrayLike(value);
                    if (null == value) throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
                    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) return function(array, byteOffset, length) {
                        if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
                        if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
                        array = void 0 === byteOffset && void 0 === length ? new Uint8Array(array) : void 0 === length ? new Uint8Array(array, byteOffset) : new Uint8Array(array, byteOffset, length);
                        return array.__proto__ = Buffer.prototype, array;
                    }(value, encodingOrOffset, length);
                    if ("number" == typeof value) throw new TypeError('The "value" argument must not be of type number. Received type number');
                    var valueOf = value.valueOf && value.valueOf();
                    if (null != valueOf && valueOf !== value) return Buffer.from(valueOf, encodingOrOffset, length);
                    valueOf = function(obj) {
                        {
                            var len, buf;
                            if (Buffer.isBuffer(obj)) return len = 0 | checked(obj.length), 0 !== (buf = createBuffer(len)).length && obj.copy(buf, 0, 0, len), buf;
                        }
                        if (void 0 !== obj.length) return "number" != typeof obj.length || numberIsNaN(obj.length) ? createBuffer(0) : fromArrayLike(obj);
                        if ("Buffer" === obj.type && Array.isArray(obj.data)) return fromArrayLike(obj.data);
                    }(value);
                    if (valueOf) return valueOf;
                    if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof value[Symbol.toPrimitive]) return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
                    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
                }
                function assertSize(size) {
                    if ("number" != typeof size) throw new TypeError('"size" argument must be of type number');
                    if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
                }
                function allocUnsafe(size) {
                    return assertSize(size), createBuffer(size < 0 ? 0 : 0 | checked(size));
                }
                function fromArrayLike(array) {
                    for (var length = array.length < 0 ? 0 : 0 | checked(array.length), buf = createBuffer(length), i = 0; i < length; i += 1) buf[i] = 255 & array[i];
                    return buf;
                }
                function checked(length) {
                    if (K_MAX_LENGTH <= length) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
                    return 0 | length;
                }
                function byteLength(string, encoding) {
                    if (Buffer.isBuffer(string)) return string.length;
                    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) return string.byteLength;
                    if ("string" != typeof string) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
                    var len = string.length, mustMatch = 2 < arguments.length && !0 === arguments[2];
                    if (!mustMatch && 0 === len) return 0;
                    for (var loweredCase = !1; ;) switch (encoding) {
                      case "ascii":
                      case "latin1":
                      case "binary":
                        return len;

                      case "utf8":
                      case "utf-8":
                        return utf8ToBytes(string).length;

                      case "ucs2":
                      case "ucs-2":
                      case "utf16le":
                      case "utf-16le":
                        return 2 * len;

                      case "hex":
                        return len >>> 1;

                      case "base64":
                        return base64ToBytes(string).length;

                      default:
                        if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string).length;
                        encoding = ("" + encoding).toLowerCase(), loweredCase = !0;
                    }
                }
                function slowToString(encoding, start, end) {
                    var loweredCase = !1;
                    if ((start = void 0 === start || start < 0 ? 0 : start) > this.length) return "";
                    if ((end = void 0 === end || end > this.length ? this.length : end) <= 0) return "";
                    if ((end >>>= 0) <= (start >>>= 0)) return "";
                    for (encoding = encoding || "utf8"; ;) switch (encoding) {
                      case "hex":
                        return function(buf, start, end) {
                            var len = buf.length;
                            (!start || start < 0) && (start = 0);
                            (!end || end < 0 || len < end) && (end = len);
                            for (var out = "", i = start; i < end; ++i) out += function(n) {
                                return n < 16 ? "0" + n.toString(16) : n.toString(16);
                            }(buf[i]);
                            return out;
                        }(this, start, end);

                      case "utf8":
                      case "utf-8":
                        return utf8Slice(this, start, end);

                      case "ascii":
                        return function(buf, start, end) {
                            var ret = "";
                            end = Math.min(buf.length, end);
                            for (var i = start; i < end; ++i) ret += String.fromCharCode(127 & buf[i]);
                            return ret;
                        }(this, start, end);

                      case "latin1":
                      case "binary":
                        return function(buf, start, end) {
                            var ret = "";
                            end = Math.min(buf.length, end);
                            for (var i = start; i < end; ++i) ret += String.fromCharCode(buf[i]);
                            return ret;
                        }(this, start, end);

                      case "base64":
                        return function(buf, start, end) {
                            return 0 === start && end === buf.length ? _$base64Js_2.fromByteArray(buf) : _$base64Js_2.fromByteArray(buf.slice(start, end));
                        }(this, start, end);

                      case "ucs2":
                      case "ucs-2":
                      case "utf16le":
                      case "utf-16le":
                        return function(buf, start, end) {
                            for (var bytes = buf.slice(start, end), res = "", i = 0; i < bytes.length; i += 2) res += String.fromCharCode(bytes[i] + 256 * bytes[i + 1]);
                            return res;
                        }(this, start, end);

                      default:
                        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                        encoding = (encoding + "").toLowerCase(), loweredCase = !0;
                    }
                }
                function swap(b, n, m) {
                    var i = b[n];
                    b[n] = b[m], b[m] = i;
                }
                function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
                    if (0 === buffer.length) return -1;
                    if ("string" == typeof byteOffset ? (encoding = byteOffset, byteOffset = 0) : 2147483647 < byteOffset ? byteOffset = 2147483647 : byteOffset < -2147483648 && (byteOffset = -2147483648), (byteOffset = (byteOffset = numberIsNaN(byteOffset = +byteOffset) ? dir ? 0 : buffer.length - 1 : byteOffset) < 0 ? buffer.length + byteOffset : byteOffset) >= buffer.length) {
                        if (dir) return -1;
                        byteOffset = buffer.length - 1;
                    } else if (byteOffset < 0) {
                        if (!dir) return -1;
                        byteOffset = 0;
                    }
                    if ("string" == typeof val && (val = Buffer.from(val, encoding)), Buffer.isBuffer(val)) return 0 === val.length ? -1 : arrayIndexOf(buffer, val, byteOffset, encoding, dir);
                    if ("number" == typeof val) return val &= 255, "function" == typeof Uint8Array.prototype.indexOf ? (dir ? Uint8Array.prototype.indexOf : Uint8Array.prototype.lastIndexOf).call(buffer, val, byteOffset) : arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir);
                    throw new TypeError("val must be string, number or Buffer");
                }
                function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
                    var indexSize = 1, arrLength = arr.length, valLength = val.length;
                    if (void 0 !== encoding && ("ucs2" === (encoding = String(encoding).toLowerCase()) || "ucs-2" === encoding || "utf16le" === encoding || "utf-16le" === encoding)) {
                        if (arr.length < 2 || val.length < 2) return -1;
                        arrLength /= indexSize = 2, valLength /= 2, byteOffset /= 2;
                    }
                    function read(buf, i) {
                        return 1 === indexSize ? buf[i] : buf.readUInt16BE(i * indexSize);
                    }
                    if (dir) for (var foundIndex = -1, i = byteOffset; i < arrLength; i++) if (read(arr, i) === read(val, -1 === foundIndex ? 0 : i - foundIndex)) {
                        if (i - (foundIndex = -1 === foundIndex ? i : foundIndex) + 1 === valLength) return foundIndex * indexSize;
                    } else -1 !== foundIndex && (i -= i - foundIndex), foundIndex = -1; else for (i = byteOffset = arrLength < byteOffset + valLength ? arrLength - valLength : byteOffset; 0 <= i; i--) {
                        for (var found = !0, j = 0; j < valLength; j++) if (read(arr, i + j) !== read(val, j)) {
                            found = !1;
                            break;
                        }
                        if (found) return i;
                    }
                    return -1;
                }
                function asciiWrite(buf, string, offset, length) {
                    return blitBuffer(function(str) {
                        for (var byteArray = [], i = 0; i < str.length; ++i) byteArray.push(255 & str.charCodeAt(i));
                        return byteArray;
                    }(string), buf, offset, length);
                }
                function ucs2Write(buf, string, offset, length) {
                    return blitBuffer(function(str, units) {
                        for (var c, hi, byteArray = [], i = 0; i < str.length && !((units -= 2) < 0); ++i) c = str.charCodeAt(i), hi = c >> 8, byteArray.push(c % 256), byteArray.push(hi);
                        return byteArray;
                    }(string, buf.length - offset), buf, offset, length);
                }
                function utf8Slice(buf, start, end) {
                    end = Math.min(buf.length, end);
                    for (var res = [], i = start; i < end; ) {
                        var secondByte, thirdByte, fourthByte, tempCodePoint, firstByte = buf[i], codePoint = null, bytesPerSequence = 239 < firstByte ? 4 : 223 < firstByte ? 3 : 191 < firstByte ? 2 : 1;
                        if (i + bytesPerSequence <= end) switch (bytesPerSequence) {
                          case 1:
                            firstByte < 128 && (codePoint = firstByte);
                            break;

                          case 2:
                            128 == (192 & (secondByte = buf[i + 1])) && 127 < (tempCodePoint = (31 & firstByte) << 6 | 63 & secondByte) && (codePoint = tempCodePoint);
                            break;

                          case 3:
                            secondByte = buf[i + 1], thirdByte = buf[i + 2], 128 == (192 & secondByte) && 128 == (192 & thirdByte) && 2047 < (tempCodePoint = (15 & firstByte) << 12 | (63 & secondByte) << 6 | 63 & thirdByte) && (tempCodePoint < 55296 || 57343 < tempCodePoint) && (codePoint = tempCodePoint);
                            break;

                          case 4:
                            secondByte = buf[i + 1], thirdByte = buf[i + 2], fourthByte = buf[i + 3], 128 == (192 & secondByte) && 128 == (192 & thirdByte) && 128 == (192 & fourthByte) && 65535 < (tempCodePoint = (15 & firstByte) << 18 | (63 & secondByte) << 12 | (63 & thirdByte) << 6 | 63 & fourthByte) && tempCodePoint < 1114112 && (codePoint = tempCodePoint);
                        }
                        null === codePoint ? (codePoint = 65533, bytesPerSequence = 1) : 65535 < codePoint && (res.push((codePoint -= 65536) >>> 10 & 1023 | 55296), codePoint = 56320 | 1023 & codePoint), res.push(codePoint), i += bytesPerSequence;
                    }
                    return function(codePoints) {
                        var len = codePoints.length;
                        if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints);
                        var res = "", i = 0;
                        for (;i < len; ) res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
                        return res;
                    }(res);
                }
                (Buffer.TYPED_ARRAY_SUPPORT = function() {
                    try {
                        var arr = new Uint8Array(1);
                        return arr.__proto__ = {
                            __proto__: Uint8Array.prototype,
                            foo: function() {
                                return 42;
                            }
                        }, 42 === arr.foo();
                    } catch (e) {
                        return !1;
                    }
                }()) || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(Buffer.prototype, "parent", {
                    enumerable: !0,
                    get: function() {
                        if (Buffer.isBuffer(this)) return this.buffer;
                    }
                }), Object.defineProperty(Buffer.prototype, "offset", {
                    enumerable: !0,
                    get: function() {
                        if (Buffer.isBuffer(this)) return this.byteOffset;
                    }
                }), "undefined" != typeof Symbol && null != Symbol.species && Buffer[Symbol.species] === Buffer && Object.defineProperty(Buffer, Symbol.species, {
                    value: null,
                    configurable: !0,
                    enumerable: !1,
                    writable: !1
                }), Buffer.poolSize = 8192, Buffer.from = from, Buffer.prototype.__proto__ = Uint8Array.prototype, Buffer.__proto__ = Uint8Array, Buffer.alloc = function(size, fill, encoding) {
                    return assertSize(size), !(size <= 0) && void 0 !== fill ? "string" == typeof encoding ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill) : createBuffer(size);
                }, Buffer.allocUnsafe = allocUnsafe, Buffer.allocUnsafeSlow = allocUnsafe, Buffer.isBuffer = function(b) {
                    return null != b && !0 === b._isBuffer && b !== Buffer.prototype;
                }, Buffer.compare = function(a, b) {
                    if (isInstance(a, Uint8Array) && (a = Buffer.from(a, a.offset, a.byteLength)), isInstance(b, Uint8Array) && (b = Buffer.from(b, b.offset, b.byteLength)), !Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                    if (a === b) return 0;
                    for (var x = a.length, y = b.length, i = 0, len = Math.min(x, y); i < len; ++i) if (a[i] !== b[i]) {
                        x = a[i], y = b[i];
                        break;
                    }
                    return x < y ? -1 : y < x ? 1 : 0;
                }, Buffer.isEncoding = function(encoding) {
                    switch (String(encoding).toLowerCase()) {
                      case "hex":
                      case "utf8":
                      case "utf-8":
                      case "ascii":
                      case "latin1":
                      case "binary":
                      case "base64":
                      case "ucs2":
                      case "ucs-2":
                      case "utf16le":
                      case "utf-16le":
                        return !0;

                      default:
                        return !1;
                    }
                }, Buffer.concat = function(list, length) {
                    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
                    if (0 === list.length) return Buffer.alloc(0);
                    if (void 0 === length) for (i = length = 0; i < list.length; ++i) length += list[i].length;
                    for (var buffer = Buffer.allocUnsafe(length), pos = 0, i = 0; i < list.length; ++i) {
                        var buf = list[i];
                        if (isInstance(buf, Uint8Array) && (buf = Buffer.from(buf)), !Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
                        buf.copy(buffer, pos), pos += buf.length;
                    }
                    return buffer;
                }, Buffer.byteLength = byteLength, Buffer.prototype._isBuffer = !0, Buffer.prototype.swap16 = function() {
                    var len = this.length;
                    if (len % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
                    for (var i = 0; i < len; i += 2) swap(this, i, i + 1);
                    return this;
                }, Buffer.prototype.swap32 = function() {
                    var len = this.length;
                    if (len % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
                    for (var i = 0; i < len; i += 4) swap(this, i, i + 3), swap(this, i + 1, i + 2);
                    return this;
                }, Buffer.prototype.swap64 = function() {
                    var len = this.length;
                    if (len % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
                    for (var i = 0; i < len; i += 8) swap(this, i, i + 7), swap(this, i + 1, i + 6), swap(this, i + 2, i + 5), swap(this, i + 3, i + 4);
                    return this;
                }, Buffer.prototype.toLocaleString = Buffer.prototype.toString = function() {
                    var length = this.length;
                    return 0 === length ? "" : 0 === arguments.length ? utf8Slice(this, 0, length) : slowToString.apply(this, arguments);
                }, Buffer.prototype.equals = function(b) {
                    if (Buffer.isBuffer(b)) return this === b || 0 === Buffer.compare(this, b);
                    throw new TypeError("Argument must be a Buffer");
                }, Buffer.prototype.inspect = function() {
                    var str = "", max = exports.INSPECT_MAX_BYTES, str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
                    return this.length > max && (str += " ... "), "<Buffer " + str + ">";
                }, Buffer.prototype.compare = function(target, start, end, thisStart, thisEnd) {
                    if (isInstance(target, Uint8Array) && (target = Buffer.from(target, target.offset, target.byteLength)), !Buffer.isBuffer(target)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
                    if (void 0 === end && (end = target ? target.length : 0), void 0 === thisStart && (thisStart = 0), void 0 === thisEnd && (thisEnd = this.length), (start = void 0 === start ? 0 : start) < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError("out of range index");
                    if (thisEnd <= thisStart && end <= start) return 0;
                    if (thisEnd <= thisStart) return -1;
                    if (end <= start) return 1;
                    if (this === target) return 0;
                    for (var x = (thisEnd >>>= 0) - (thisStart >>>= 0), y = (end >>>= 0) - (start >>>= 0), len = Math.min(x, y), thisCopy = this.slice(thisStart, thisEnd), targetCopy = target.slice(start, end), i = 0; i < len; ++i) if (thisCopy[i] !== targetCopy[i]) {
                        x = thisCopy[i], y = targetCopy[i];
                        break;
                    }
                    return x < y ? -1 : y < x ? 1 : 0;
                }, Buffer.prototype.includes = function(val, byteOffset, encoding) {
                    return -1 !== this.indexOf(val, byteOffset, encoding);
                }, Buffer.prototype.indexOf = function(val, byteOffset, encoding) {
                    return bidirectionalIndexOf(this, val, byteOffset, encoding, !0);
                }, Buffer.prototype.lastIndexOf = function(val, byteOffset, encoding) {
                    return bidirectionalIndexOf(this, val, byteOffset, encoding, !1);
                }, Buffer.prototype.write = function(string, offset, length, encoding) {
                    if (void 0 === offset) encoding = "utf8", length = this.length, offset = 0; else if (void 0 === length && "string" == typeof offset) encoding = offset, length = this.length, offset = 0; else {
                        if (!isFinite(offset)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                        offset >>>= 0, isFinite(length) ? (length >>>= 0, void 0 === encoding && (encoding = "utf8")) : (encoding = length, length = void 0);
                    }
                    var remaining = this.length - offset;
                    if ((void 0 === length || remaining < length) && (length = remaining), 0 < string.length && (length < 0 || offset < 0) || offset > this.length) throw new RangeError("Attempt to write outside buffer bounds");
                    encoding = encoding || "utf8";
                    for (var loweredCase = !1; ;) switch (encoding) {
                      case "hex":
                        return function(buf, string, offset, length) {
                            offset = Number(offset) || 0;
                            var remaining = buf.length - offset;
                            (!length || remaining < (length = Number(length))) && (length = remaining), (remaining = string.length) / 2 < length && (length = remaining / 2);
                            for (var i = 0; i < length; ++i) {
                                var parsed = parseInt(string.substr(2 * i, 2), 16);
                                if (numberIsNaN(parsed)) return i;
                                buf[offset + i] = parsed;
                            }
                            return i;
                        }(this, string, offset, length);

                      case "utf8":
                      case "utf-8":
                        return function(buf, string, offset, length) {
                            return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
                        }(this, string, offset, length);

                      case "ascii":
                        return asciiWrite(this, string, offset, length);

                      case "latin1":
                      case "binary":
                        return asciiWrite(this, string, offset, length);

                      case "base64":
                        return function(buf, string, offset, length) {
                            return blitBuffer(base64ToBytes(string), buf, offset, length);
                        }(this, string, offset, length);

                      case "ucs2":
                      case "ucs-2":
                      case "utf16le":
                      case "utf-16le":
                        return ucs2Write(this, string, offset, length);

                      default:
                        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                        encoding = ("" + encoding).toLowerCase(), loweredCase = !0;
                    }
                }, Buffer.prototype.toJSON = function() {
                    return {
                        type: "Buffer",
                        data: Array.prototype.slice.call(this._arr || this, 0)
                    };
                };
                var MAX_ARGUMENTS_LENGTH = 4096;
                function checkOffset(offset, ext, length) {
                    if (offset % 1 != 0 || offset < 0) throw new RangeError("offset is not uint");
                    if (length < offset + ext) throw new RangeError("Trying to access beyond buffer length");
                }
                function checkInt(buf, value, offset, ext, max, min) {
                    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
                    if (max < value || value < min) throw new RangeError('"value" argument is out of bounds');
                    if (offset + ext > buf.length) throw new RangeError("Index out of range");
                }
                function checkIEEE754(buf, value, offset, ext) {
                    if (offset + ext > buf.length) throw new RangeError("Index out of range");
                    if (offset < 0) throw new RangeError("Index out of range");
                }
                function writeFloat(buf, value, offset, littleEndian, noAssert) {
                    return value = +value, offset >>>= 0, noAssert || checkIEEE754(buf, 0, offset, 4), _$ieee754_4.write(buf, value, offset, littleEndian, 23, 4), offset + 4;
                }
                function writeDouble(buf, value, offset, littleEndian, noAssert) {
                    return value = +value, offset >>>= 0, noAssert || checkIEEE754(buf, 0, offset, 8), _$ieee754_4.write(buf, value, offset, littleEndian, 52, 8), offset + 8;
                }
                Buffer.prototype.slice = function(start, end) {
                    var len = this.length, len = ((start = ~~start) < 0 ? (start += len) < 0 && (start = 0) : len < start && (start = len), (end = void 0 === end ? len : ~~end) < 0 ? (end += len) < 0 && (end = 0) : len < end && (end = len), end < start && (end = start), this.subarray(start, end));
                    return len.__proto__ = Buffer.prototype, len;
                }, Buffer.prototype.readUIntLE = function(offset, byteLength, noAssert) {
                    offset >>>= 0, byteLength >>>= 0, noAssert || checkOffset(offset, byteLength, this.length);
                    for (var val = this[offset], mul = 1, i = 0; ++i < byteLength && (mul *= 256); ) val += this[offset + i] * mul;
                    return val;
                }, Buffer.prototype.readUIntBE = function(offset, byteLength, noAssert) {
                    offset >>>= 0, byteLength >>>= 0, noAssert || checkOffset(offset, byteLength, this.length);
                    for (var val = this[offset + --byteLength], mul = 1; 0 < byteLength && (mul *= 256); ) val += this[offset + --byteLength] * mul;
                    return val;
                }, Buffer.prototype.readUInt8 = function(offset, noAssert) {
                    return offset >>>= 0, noAssert || checkOffset(offset, 1, this.length), this[offset];
                }, Buffer.prototype.readUInt16LE = function(offset, noAssert) {
                    return offset >>>= 0, noAssert || checkOffset(offset, 2, this.length), this[offset] | this[offset + 1] << 8;
                }, Buffer.prototype.readUInt16BE = function(offset, noAssert) {
                    return offset >>>= 0, noAssert || checkOffset(offset, 2, this.length), this[offset] << 8 | this[offset + 1];
                }, Buffer.prototype.readUInt32LE = function(offset, noAssert) {
                    return offset >>>= 0, noAssert || checkOffset(offset, 4, this.length), (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + 16777216 * this[offset + 3];
                }, Buffer.prototype.readUInt32BE = function(offset, noAssert) {
                    return offset >>>= 0, noAssert || checkOffset(offset, 4, this.length), 16777216 * this[offset] + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
                }, Buffer.prototype.readIntLE = function(offset, byteLength, noAssert) {
                    offset >>>= 0, byteLength >>>= 0, noAssert || checkOffset(offset, byteLength, this.length);
                    for (var val = this[offset], mul = 1, i = 0; ++i < byteLength && (mul *= 256); ) val += this[offset + i] * mul;
                    return (mul *= 128) <= val && (val -= Math.pow(2, 8 * byteLength)), val;
                }, Buffer.prototype.readIntBE = function(offset, byteLength, noAssert) {
                    offset >>>= 0, byteLength >>>= 0, noAssert || checkOffset(offset, byteLength, this.length);
                    for (var i = byteLength, mul = 1, val = this[offset + --i]; 0 < i && (mul *= 256); ) val += this[offset + --i] * mul;
                    return (mul *= 128) <= val && (val -= Math.pow(2, 8 * byteLength)), val;
                }, Buffer.prototype.readInt8 = function(offset, noAssert) {
                    return offset >>>= 0, noAssert || checkOffset(offset, 1, this.length), 128 & this[offset] ? -1 * (255 - this[offset] + 1) : this[offset];
                }, Buffer.prototype.readInt16LE = function(offset, noAssert) {
                    offset >>>= 0, noAssert || checkOffset(offset, 2, this.length);
                    noAssert = this[offset] | this[offset + 1] << 8;
                    return 32768 & noAssert ? 4294901760 | noAssert : noAssert;
                }, Buffer.prototype.readInt16BE = function(offset, noAssert) {
                    offset >>>= 0, noAssert || checkOffset(offset, 2, this.length);
                    noAssert = this[offset + 1] | this[offset] << 8;
                    return 32768 & noAssert ? 4294901760 | noAssert : noAssert;
                }, Buffer.prototype.readInt32LE = function(offset, noAssert) {
                    return offset >>>= 0, noAssert || checkOffset(offset, 4, this.length), this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
                }, Buffer.prototype.readInt32BE = function(offset, noAssert) {
                    return offset >>>= 0, noAssert || checkOffset(offset, 4, this.length), this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
                }, Buffer.prototype.readFloatLE = function(offset, noAssert) {
                    return offset >>>= 0, noAssert || checkOffset(offset, 4, this.length), _$ieee754_4.read(this, offset, !0, 23, 4);
                }, Buffer.prototype.readFloatBE = function(offset, noAssert) {
                    return offset >>>= 0, noAssert || checkOffset(offset, 4, this.length), _$ieee754_4.read(this, offset, !1, 23, 4);
                }, Buffer.prototype.readDoubleLE = function(offset, noAssert) {
                    return offset >>>= 0, noAssert || checkOffset(offset, 8, this.length), _$ieee754_4.read(this, offset, !0, 52, 8);
                }, Buffer.prototype.readDoubleBE = function(offset, noAssert) {
                    return offset >>>= 0, noAssert || checkOffset(offset, 8, this.length), _$ieee754_4.read(this, offset, !1, 52, 8);
                }, Buffer.prototype.writeUIntLE = function(value, offset, byteLength, noAssert) {
                    value = +value, offset >>>= 0, byteLength >>>= 0, noAssert || checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength) - 1, 0);
                    var mul = 1, i = 0;
                    for (this[offset] = 255 & value; ++i < byteLength && (mul *= 256); ) this[offset + i] = value / mul & 255;
                    return offset + byteLength;
                }, Buffer.prototype.writeUIntBE = function(value, offset, byteLength, noAssert) {
                    value = +value, offset >>>= 0, byteLength >>>= 0, noAssert || checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength) - 1, 0);
                    var i = byteLength - 1, mul = 1;
                    for (this[offset + i] = 255 & value; 0 <= --i && (mul *= 256); ) this[offset + i] = value / mul & 255;
                    return offset + byteLength;
                }, Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
                    return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 1, 255, 0), this[offset] = 255 & value, offset + 1;
                }, Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
                    return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 2, 65535, 0), this[offset] = 255 & value, this[offset + 1] = value >>> 8, offset + 2;
                }, Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
                    return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 2, 65535, 0), this[offset] = value >>> 8, this[offset + 1] = 255 & value, offset + 2;
                }, Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
                    return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 4, 4294967295, 0), this[offset + 3] = value >>> 24, this[offset + 2] = value >>> 16, this[offset + 1] = value >>> 8, this[offset] = 255 & value, offset + 4;
                }, Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
                    return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 4, 4294967295, 0), this[offset] = value >>> 24, this[offset + 1] = value >>> 16, this[offset + 2] = value >>> 8, this[offset + 3] = 255 & value, offset + 4;
                }, Buffer.prototype.writeIntLE = function(value, offset, byteLength, noAssert) {
                    value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, byteLength, (noAssert = Math.pow(2, 8 * byteLength - 1)) - 1, -noAssert);
                    var i = 0, mul = 1, sub = 0;
                    for (this[offset] = 255 & value; ++i < byteLength && (mul *= 256); ) value < 0 && 0 === sub && 0 !== this[offset + i - 1] && (sub = 1), this[offset + i] = (value / mul >> 0) - sub & 255;
                    return offset + byteLength;
                }, Buffer.prototype.writeIntBE = function(value, offset, byteLength, noAssert) {
                    value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, byteLength, (noAssert = Math.pow(2, 8 * byteLength - 1)) - 1, -noAssert);
                    var i = byteLength - 1, mul = 1, sub = 0;
                    for (this[offset + i] = 255 & value; 0 <= --i && (mul *= 256); ) value < 0 && 0 === sub && 0 !== this[offset + i + 1] && (sub = 1), this[offset + i] = (value / mul >> 0) - sub & 255;
                    return offset + byteLength;
                }, Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
                    return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 1, 127, -128), this[offset] = 255 & (value = value < 0 ? 255 + value + 1 : value), offset + 1;
                }, Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
                    return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 2, 32767, -32768), this[offset] = 255 & value, this[offset + 1] = value >>> 8, offset + 2;
                }, Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
                    return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 2, 32767, -32768), this[offset] = value >>> 8, this[offset + 1] = 255 & value, offset + 2;
                }, Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
                    return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 4, 2147483647, -2147483648), this[offset] = 255 & value, this[offset + 1] = value >>> 8, this[offset + 2] = value >>> 16, this[offset + 3] = value >>> 24, offset + 4;
                }, Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
                    return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 4, 2147483647, -2147483648), this[offset] = (value = value < 0 ? 4294967295 + value + 1 : value) >>> 24, this[offset + 1] = value >>> 16, this[offset + 2] = value >>> 8, this[offset + 3] = 255 & value, offset + 4;
                }, Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
                    return writeFloat(this, value, offset, !0, noAssert);
                }, Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
                    return writeFloat(this, value, offset, !1, noAssert);
                }, Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
                    return writeDouble(this, value, offset, !0, noAssert);
                }, Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
                    return writeDouble(this, value, offset, !1, noAssert);
                }, Buffer.prototype.copy = function(target, targetStart, start, end) {
                    if (!Buffer.isBuffer(target)) throw new TypeError("argument should be a Buffer");
                    if (start = start || 0, end || 0 === end || (end = this.length), targetStart >= target.length && (targetStart = target.length), (end = 0 < end && end < start ? start : end) === start) return 0;
                    if (0 === target.length || 0 === this.length) return 0;
                    if ((targetStart = targetStart || 0) < 0) throw new RangeError("targetStart out of bounds");
                    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
                    if (end < 0) throw new RangeError("sourceEnd out of bounds");
                    end > this.length && (end = this.length);
                    var len = (end = target.length - targetStart < end - start ? target.length - targetStart + start : end) - start;
                    if (this === target && "function" == typeof Uint8Array.prototype.copyWithin) this.copyWithin(targetStart, start, end); else if (this === target && start < targetStart && targetStart < end) for (var i = len - 1; 0 <= i; --i) target[i + targetStart] = this[i + start]; else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
                    return len;
                }, Buffer.prototype.fill = function(val, start, end, encoding) {
                    if ("string" == typeof val) {
                        if ("string" == typeof start ? (encoding = start, start = 0, end = this.length) : "string" == typeof end && (encoding = end, end = this.length), void 0 !== encoding && "string" != typeof encoding) throw new TypeError("encoding must be a string");
                        if ("string" == typeof encoding && !Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
                        var code;
                        1 === val.length && (code = val.charCodeAt(0), "utf8" === encoding && code < 128 || "latin1" === encoding) && (val = code);
                    } else "number" == typeof val && (val &= 255);
                    if (start < 0 || this.length < start || this.length < end) throw new RangeError("Out of range index");
                    var i;
                    if (!(end <= start)) if (start >>>= 0, end = void 0 === end ? this.length : end >>> 0, "number" == typeof (val = val || 0)) for (i = start; i < end; ++i) this[i] = val; else {
                        var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding), len = bytes.length;
                        if (0 === len) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
                        for (i = 0; i < end - start; ++i) this[i + start] = bytes[i % len];
                    }
                    return this;
                };
                var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
                function utf8ToBytes(string, units) {
                    units = units || 1 / 0;
                    for (var codePoint, length = string.length, leadSurrogate = null, bytes = [], i = 0; i < length; ++i) {
                        if (55295 < (codePoint = string.charCodeAt(i)) && codePoint < 57344) {
                            if (!leadSurrogate) {
                                if (56319 < codePoint) {
                                    -1 < (units -= 3) && bytes.push(239, 191, 189);
                                    continue;
                                }
                                if (i + 1 === length) {
                                    -1 < (units -= 3) && bytes.push(239, 191, 189);
                                    continue;
                                }
                                leadSurrogate = codePoint;
                                continue;
                            }
                            if (codePoint < 56320) {
                                -1 < (units -= 3) && bytes.push(239, 191, 189), leadSurrogate = codePoint;
                                continue;
                            }
                            codePoint = 65536 + (leadSurrogate - 55296 << 10 | codePoint - 56320);
                        } else leadSurrogate && -1 < (units -= 3) && bytes.push(239, 191, 189);
                        if (leadSurrogate = null, codePoint < 128) {
                            if (--units < 0) break;
                            bytes.push(codePoint);
                        } else if (codePoint < 2048) {
                            if ((units -= 2) < 0) break;
                            bytes.push(codePoint >> 6 | 192, 63 & codePoint | 128);
                        } else if (codePoint < 65536) {
                            if ((units -= 3) < 0) break;
                            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, 63 & codePoint | 128);
                        } else {
                            if (!(codePoint < 1114112)) throw new Error("Invalid code point");
                            if ((units -= 4) < 0) break;
                            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, 63 & codePoint | 128);
                        }
                    }
                    return bytes;
                }
                function base64ToBytes(str) {
                    return _$base64Js_2.toByteArray(function(str) {
                        if ((str = (str = str.split("=")[0]).trim().replace(INVALID_BASE64_RE, "")).length < 2) return "";
                        for (;str.length % 4 != 0; ) str += "=";
                        return str;
                    }(str));
                }
                function blitBuffer(src, dst, offset, length) {
                    for (var i = 0; i < length && !(i + offset >= dst.length || i >= src.length); ++i) dst[i + offset] = src[i];
                    return i;
                }
                function isInstance(obj, type) {
                    return obj instanceof type || null != obj && null != obj.constructor && null != obj.constructor.name && obj.constructor.name === type.name;
                }
                function numberIsNaN(obj) {
                    return obj != obj;
                }
            }.call(this);
        }.call(this, _$buffer_3({}).Buffer);
    };
    var t, e, _$buffer_3 = function(r) {
        return e || t(e = {
            exports: {},
            parent: r
        }, e.exports), e.exports;
    }, _$base64Js_2 = {
        toByteArray: function(b64) {
            var tmp, i, lens = getLens(b64), validLen = lens[0], lens = lens[1], arr = new Arr(function(validLen, placeHoldersLen) {
                return 3 * (validLen + placeHoldersLen) / 4 - placeHoldersLen;
            }(validLen, lens)), curByte = 0, len = 0 < lens ? validLen - 4 : validLen;
            for (i = 0; i < len; i += 4) tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)], arr[curByte++] = tmp >> 16 & 255, arr[curByte++] = tmp >> 8 & 255, arr[curByte++] = 255 & tmp;
            2 === lens && (tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4, arr[curByte++] = 255 & tmp);
            1 === lens && (tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2, arr[curByte++] = tmp >> 8 & 255, arr[curByte++] = 255 & tmp);
            return arr;
        }
    };
    _$base64Js_2.fromByteArray = function(uint8) {
        for (var tmp, len = uint8.length, extraBytes = len % 3, parts = [], i = 0, len2 = len - extraBytes; i < len2; i += 16383) parts.push(function(uint8, start, end) {
            for (var tmp, output = [], i = start; i < end; i += 3) tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (255 & uint8[i + 2]), output.push(function(num) {
                return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[63 & num];
            }(tmp));
            return output.join("");
        }(uint8, i, len2 < i + 16383 ? len2 : i + 16383));
        1 == extraBytes ? (tmp = uint8[len - 1], parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==")) : 2 == extraBytes && (tmp = (uint8[len - 2] << 8) + uint8[len - 1], parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="));
        return parts.join("");
    };
    for (var lookup = [], revLookup = [], Arr = "undefined" != typeof Uint8Array ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", i = 0, len = code.length; i < len; ++i) lookup[i] = code[i], revLookup[code.charCodeAt(i)] = i;
    function getLens(b64) {
        var len = b64.length;
        if (0 < len % 4) throw new Error("Invalid string. Length must be a multiple of 4");
        b64 = b64.indexOf("="), len = (b64 = -1 === b64 ? len : b64) === len ? 0 : 4 - b64 % 4;
        return [ b64, len ];
    }
    revLookup["-".charCodeAt(0)] = 62, revLookup["_".charCodeAt(0)] = 63;
    var _$ieee754_4 = {
        read: function(buffer, offset, isLE, mLen, nBytes) {
            var e, m, eLen = 8 * nBytes - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, nBits = -7, i = isLE ? nBytes - 1 : 0, d = isLE ? -1 : 1, nBytes = buffer[offset + i];
            for (i += d, e = nBytes & (1 << -nBits) - 1, nBytes >>= -nBits, nBits += eLen; 0 < nBits; e = 256 * e + buffer[offset + i], i += d, nBits -= 8);
            for (m = e & (1 << -nBits) - 1, e >>= -nBits, nBits += mLen; 0 < nBits; m = 256 * m + buffer[offset + i], i += d, nBits -= 8);
            if (0 === e) e = 1 - eBias; else {
                if (e === eMax) return m ? NaN : 1 / 0 * (nBytes ? -1 : 1);
                m += Math.pow(2, mLen), e -= eBias;
            }
            return (nBytes ? -1 : 1) * m * Math.pow(2, e - mLen);
        },
        write: function(buffer, value, offset, isLE, mLen, nBytes) {
            var e, m, eLen = 8 * nBytes - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, rt = 23 === mLen ? Math.pow(2, -24) - Math.pow(2, -77) : 0, i = isLE ? 0 : nBytes - 1, d = isLE ? 1 : -1, nBytes = value < 0 || 0 === value && 1 / value < 0 ? 1 : 0;
            for (value = Math.abs(value), isNaN(value) || value === 1 / 0 ? (m = isNaN(value) ? 1 : 0, e = eMax) : (e = Math.floor(Math.log(value) / Math.LN2), value * (isLE = Math.pow(2, -e)) < 1 && (e--, isLE *= 2), 2 <= (value += 1 <= e + eBias ? rt / isLE : rt * Math.pow(2, 1 - eBias)) * isLE && (e++, isLE /= 2), eMax <= e + eBias ? (m = 0, e = eMax) : 1 <= e + eBias ? (m = (value * isLE - 1) * Math.pow(2, mLen), e += eBias) : (m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen), e = 0)); 8 <= mLen; buffer[offset + i] = 255 & m, i += d, m /= 256, mLen -= 8);
            for (e = e << mLen | m, eLen += mLen; 0 < eLen; buffer[offset + i] = 255 & e, i += d, e /= 256, eLen -= 8);
            buffer[offset + i - d] |= 128 * nBytes;
        }
    }, _$browser_6 = {
        networkInterfaces: function() {
            return {};
        }
    }, _$ip_5 = {};
    let ip = _$ip_5, Buffer = _$buffer_3({})["Buffer"], ipv4Regex = (ip.toBuffer = function(ip, buff, offset) {
        offset = ~~offset;
        let result;
        if (this.isV4Format(ip)) result = buff || Buffer.alloc(offset + 4), ip.split(/\./g).map(byte => {
            result[offset++] = 255 & parseInt(byte, 10);
        }); else if (this.isV6Format(ip)) {
            var sections = ip.split(":", 8);
            let i;
            for (i = 0; i < sections.length; i++) {
                let v4Buffer;
                this.isV4Format(sections[i]) && (v4Buffer = this.toBuffer(sections[i]), sections[i] = v4Buffer.slice(0, 2).toString("hex")), v4Buffer && ++i < 8 && sections.splice(i, 0, v4Buffer.slice(2, 4).toString("hex"));
            }
            if ("" === sections[0]) for (;sections.length < 8; ) sections.unshift("0"); else if ("" === sections[sections.length - 1]) for (;sections.length < 8; ) sections.push("0"); else if (sections.length < 8) {
                for (i = 0; i < sections.length && "" !== sections[i]; i++);
                var argv = [ i, 1 ];
                for (i = 9 - sections.length; 0 < i; i--) argv.push("0");
                sections.splice(...argv);
            }
            for (result = buff || Buffer.alloc(offset + 16), i = 0; i < sections.length; i++) {
                var word = parseInt(sections[i], 16);
                result[offset++] = word >> 8 & 255, result[offset++] = 255 & word;
            }
        }
        if (result) return result;
        throw Error("Invalid ip address: " + ip);
    }, ip.toString = function(buff, offset, length) {
        offset = ~~offset;
        let result = [];
        if (4 === (length = length || buff.length - offset)) {
            for (let i = 0; i < length; i++) result.push(buff[offset + i]);
            result = result.join(".");
        } else if (16 === length) {
            for (let i = 0; i < length; i += 2) result.push(buff.readUInt16BE(offset + i).toString(16));
            result = (result = (result = result.join(":")).replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3")).replace(/:{3,4}/, "::");
        }
        return result;
    }, /^(\d{1,3}\.){3,3}\d{1,3}$/), ipv6Regex = /^(::)?(((\d{1,3}\.){3}(\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?$/i;
    function _normalizeFamily(family) {
        return 4 === family ? "ipv4" : 6 === family ? "ipv6" : family ? family.toLowerCase() : "ipv4";
    }
    ip.isV4Format = function(ip) {
        return ipv4Regex.test(ip);
    }, ip.isV6Format = function(ip) {
        return ipv6Regex.test(ip);
    }, ip.fromPrefixLen = function(prefixlen, family) {
        let len = 4;
        "ipv6" === (family = 32 < prefixlen ? "ipv6" : _normalizeFamily(family)) && (len = 16);
        var buff = Buffer.alloc(len);
        for (let i = 0, n = buff.length; i < n; ++i) {
            let bits = prefixlen < 8 ? prefixlen : 8;
            prefixlen -= bits, buff[i] = 255 & ~(255 >> bits);
        }
        return ip.toString(buff);
    }, ip.mask = function(addr, mask) {
        addr = ip.toBuffer(addr), mask = ip.toBuffer(mask);
        var result = Buffer.alloc(Math.max(addr.length, mask.length));
        let i;
        if (addr.length === mask.length) for (i = 0; i < addr.length; i++) result[i] = addr[i] & mask[i]; else if (4 === mask.length) for (i = 0; i < mask.length; i++) result[i] = addr[addr.length - 4 + i] & mask[i]; else {
            for (i = 0; i < result.length - 6; i++) result[i] = 0;
            for (result[10] = 255, result[11] = 255, i = 0; i < addr.length; i++) result[i + 12] = addr[i] & mask[i + 12];
            i += 12;
        }
        for (;i < result.length; i++) result[i] = 0;
        return ip.toString(result);
    }, ip.cidr = function(cidrString) {
        var cidrString = cidrString.split("/"), addr = cidrString[0];
        if (2 !== cidrString.length) throw new Error("invalid CIDR subnet: " + addr);
        cidrString = ip.fromPrefixLen(parseInt(cidrString[1], 10));
        return ip.mask(addr, cidrString);
    }, ip.subnet = function(addr, mask) {
        let networkAddress = ip.toLong(ip.mask(addr, mask));
        var maskBuffer = ip.toBuffer(mask);
        let maskLength = 0;
        for (let i = 0; i < maskBuffer.length; i++) if (255 === maskBuffer[i]) maskLength += 8; else {
            let octet = 255 & maskBuffer[i];
            for (;octet; ) octet = octet << 1 & 255, maskLength++;
        }
        addr = 2 ** (32 - maskLength);
        return {
            networkAddress: ip.fromLong(networkAddress),
            firstAddress: addr <= 2 ? ip.fromLong(networkAddress) : ip.fromLong(networkAddress + 1),
            lastAddress: addr <= 2 ? ip.fromLong(networkAddress + addr - 1) : ip.fromLong(networkAddress + addr - 2),
            broadcastAddress: ip.fromLong(networkAddress + addr - 1),
            subnetMask: mask,
            subnetMaskLength: maskLength,
            numHosts: addr <= 2 ? addr : addr - 2,
            length: addr,
            contains(other) {
                return networkAddress === ip.toLong(ip.mask(other, mask));
            }
        };
    }, ip.cidrSubnet = function(cidrString) {
        var cidrString = cidrString.split("/"), addr = cidrString[0];
        if (2 !== cidrString.length) throw new Error("invalid CIDR subnet: " + addr);
        cidrString = ip.fromPrefixLen(parseInt(cidrString[1], 10));
        return ip.subnet(addr, cidrString);
    }, ip.not = function(addr) {
        var buff = ip.toBuffer(addr);
        for (let i = 0; i < buff.length; i++) buff[i] = 255 ^ buff[i];
        return ip.toString(buff);
    }, ip.or = function(a, b) {
        if (a = ip.toBuffer(a), b = ip.toBuffer(b), a.length === b.length) {
            for (let i = 0; i < a.length; ++i) a[i] |= b[i];
            return ip.toString(a);
        }
        let buff = a, other = b;
        b.length > a.length && (buff = b, other = a);
        var offset = buff.length - other.length;
        for (let i = offset; i < buff.length; ++i) buff[i] |= other[i - offset];
        return ip.toString(buff);
    }, ip.isEqual = function(a, b) {
        if (a = ip.toBuffer(a), b = ip.toBuffer(b), a.length === b.length) {
            for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return !1;
        } else {
            4 === b.length && (t = b, b = a, a = t);
            for (let i = 0; i < 10; i++) if (0 !== b[i]) return !1;
            var t = b.readUInt16BE(10);
            if (0 !== t && 65535 !== t) return !1;
            for (let i = 0; i < 4; i++) if (a[i] !== b[i + 12]) return !1;
        }
        return !0;
    }, ip.isPrivate = function(addr) {
        if (ip.isLoopback(addr)) return !0;
        if (!ip.isV6Format(addr)) {
            var ipl = ip.normalizeToLong(addr);
            if (ipl < 0) throw new Error("invalid ipv4 address");
            addr = ip.fromLong(ipl);
        }
        return /^(::f{4}:)?10\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?192\.168\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?172\.(1[6-9]|2\d|30|31)\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?169\.254\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) || /^f[cd][0-9a-f]{2}:/i.test(addr) || /^fe80:/i.test(addr) || /^::1$/.test(addr) || /^::$/.test(addr);
    }, ip.isPublic = function(addr) {
        return !ip.isPrivate(addr);
    }, ip.isLoopback = function(addr) {
        return /\./.test(addr) || /:/.test(addr) || (addr = ip.fromLong(Number(addr))), /^(::f{4}:)?127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})/.test(addr) || /^0177\./.test(addr) || /^0x7f\./i.test(addr) || /^fe80::1$/i.test(addr) || /^::1$/.test(addr) || /^::$/.test(addr);
    }, ip.loopback = function(family) {
        if ("ipv4" !== (family = _normalizeFamily(family)) && "ipv6" !== family) throw new Error("family must be ipv4 or ipv6");
        return "ipv4" === family ? "127.0.0.1" : "fe80::1";
    }, ip.address = function(name, family) {
        let interfaces = _$browser_6.networkInterfaces();
        var res;
        return family = _normalizeFamily(family), name && "private" !== name && "public" !== name ? 0 === (res = interfaces[name].filter(details => {
            return _normalizeFamily(details.family) === family;
        })).length ? void 0 : res[0].address : (res = Object.keys(interfaces).map(nic => {
            nic = interfaces[nic].filter(details => (details.family = _normalizeFamily(details.family), details.family !== family || ip.isLoopback(details.address) ? !1 : !name || ("public" === name ? ip.isPrivate(details.address) : ip.isPublic(details.address))));
            return nic.length ? nic[0].address : void 0;
        }).filter(Boolean)).length ? res[0] : ip.loopback(family);
    }, ip.toLong = function(ip) {
        let ipl = 0;
        return ip.split(".").forEach(octet => {
            ipl = (ipl <<= 8) + parseInt(octet);
        }), ipl >>> 0;
    }, ip.fromLong = function(ipl) {
        return `${ipl >>> 24}.${ipl >> 16 & 255}.${ipl >> 8 & 255}.` + (255 & ipl);
    }, ip.normalizeToLong = function(addr) {
        var parts = addr.split(".").map(part => part.startsWith("0x") || part.startsWith("0X") ? parseInt(part, 16) : part.startsWith("0") && "0" !== part && /^[0-7]+$/.test(part) ? parseInt(part, 8) : /^[1-9]\d*$/.test(part) || "0" === part ? parseInt(part, 10) : NaN);
        if (parts.some(isNaN)) return -1;
        let val = 0;
        switch (parts.length) {
          case 1:
            val = parts[0];
            break;

          case 2:
            if (255 < parts[0] || 16777215 < parts[1]) return -1;
            val = parts[0] << 24 | 16777215 & parts[1];
            break;

          case 3:
            if (255 < parts[0] || 255 < parts[1] || 65535 < parts[2]) return -1;
            val = parts[0] << 24 | parts[1] << 16 | 65535 & parts[2];
            break;

          case 4:
            if (parts.some(part => 255 < part)) return -1;
            val = parts[0] << 24 | parts[1] << 16 | parts[2] << 8 | parts[3];
            break;

          default:
            return -1;
        }
        return val >>> 0;
    };
    !function(global) {
        !function() {
            var obj = (obj = _$ip_5) && obj.__esModule ? obj : {
                default: obj
            };
            global.libip = obj.default;
        }.call(this);
    }.call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
}();
